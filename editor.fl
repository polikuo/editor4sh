# data file for the Fltk User Interface Designer (fluid)
version 1.0304
header_name {.h}
code_name {.cxx}
comment {author polikuo 2018} {in_source in_header
}

decl {\#include <FL/Fl_Double_Window.H>} {public global
}

decl {\#include <FL/Fl_Text_Editor.H>} {public global
}

decl {\#include <FL/Fl_Menu_Bar.H>} {public global
}

decl {\#include <FL/Fl_Button.H>} {public global
}

decl {\#include <FL/Fl_File_Chooser.H>} {public global
}

decl {\#include <errno.h>} {public global
}

decl {char const *SHELL = "\#!/bin/sh\\n";} {private global
}

decl {char filename[FL_PATH_MAX], title[FL_PATH_MAX];} {private global
}

decl {Fl_Text_Buffer *buff = new Fl_Text_Buffer();} {private global
}

decl {bool color = false, auto_indent = false, indenting = false, changed = false;} {private global
}

decl {Fl_Text_Buffer *stylebuf = new Fl_Text_Buffer();} {private global
}

decl {\#define TS 14} {private global
}

comment {Style table
http://www.fltk.org/doc-1.3/Enumerations_8H.html
http://www.fltk.org/doc-1.3/fltk-colormap.png
A - Plain
B - busybox
C - special_characters
D - bourne_function
E - command substitution
F - Single Quotes
G - Double Quotes
H - escapes
I - bourne_variables
J - comments
K - bourne_constructs} {in_source not_in_header
}

decl {Fl_Text_Display::Style_Table_Entry styletable[] = {
  { FL_BLACK, FL_COURIER, TS },
  { 82, FL_COURIER_BOLD, TS },
  { FL_DARK_MAGENTA, FL_COURIER_BOLD,TS },
  { 92, FL_COURIER_BOLD, TS },
  { FL_DARK_GREEN, FL_COURIER, TS },
  { FL_BLUE, FL_COURIER_BOLD, TS },
  { FL_DARK_CYAN, FL_COURIER,TS },
  { FL_DARK_YELLOW, FL_COURIER,TS },
  { FL_DARK_RED, FL_COURIER_BOLD, TS },
  { FL_DARK2, FL_COURIER_ITALIC, TS },
  { FL_MAGENTA, FL_COURIER_BOLD, TS }
};} {private global
}

Function {buffer_init()} {return_type void
} {
  code {// attach buffer to  editor
buff->text(SHELL);
edit->buffer(buff);
edit->insert_position(10);
edit->show_insert_position();
buff->add_modify_callback(modification_cb, edit);} {}
}

Function {shebang()} {return_type void
} {
  code {if (strlen(SHELL) == 0) return;
int firstline, current_pos;
current_pos = edit->insert_position();
// search_forward(int startPos, const char *searchString, int *foundPos, int matchCase = 0)
int found = buff->search_forward(0, "\\n", &firstline);
if (found) {
  buff->select(0, firstline+1);
  buff->remove_selection();
  buff->insert(0, SHELL);
  edit->insert_position(current_pos + strlen(SHELL) - firstline - 1);
  edit->show_insert_position();
} else {
  // no newline char
  buff->text(SHELL);
  edit->insert_position(strlen(SHELL));
  edit->show_insert_position();
}} {}
}

Function {check_saved(void)} {return_type int
} {
  code {// 1:good, 0:cancel
if (!changed) return 1;
int r = fl_choice(
  "The current file has not been saved.\\nWould you like to save it now?",
  "Cancel", "Save", "Don't Save"
);
// Cancel = 0, Save = 1, Don't Save = 2
if (r == 1) {
  save_cb(); // Save the file...
  return !changed;
}
if (r == 2) changed = false;
return r;} {}
}

Function {new_cb()} {return_type void
} {
  code {if (!check_saved()) return;
// coloring
if (color) {
  color_cb(); // called twice
  buff->text(SHELL);
  color_cb(); // to refresh
} else {
  buff->text(SHELL);
}
edit->insert_position(strlen(SHELL));
edit->show_insert_position();
strcpy(filename, "");
strcpy(title, "");
win->label(title);
changed = false;} {}
}

Function {save_file(const char *newfile)} {return_type void
} {
  code {// Save file
// auto append trailing "\\n"
int buff_end;
buff_end = buff->length();
char last_char;
last_char = buff->char_at(buff_end - 1);
if (last_char != 10) {
  buff->append("\\n");
  edit->insert_position(buff_end + 1);
  edit->show_insert_position();
}
// fl_alert("Saving to file %s", newfile);
if (buff->savefile(newfile)) {
  fl_alert("Error writing to file \\'%s\\':\\n%s.", newfile, strerror(errno));
} else {
  strcpy(filename, newfile);
  strcpy(title, newfile);
  win->label(title);
  changed = false;
  \#ifdef __linux__
    char chmod[FL_PATH_MAX + 9];
    sprintf(chmod, "chmod +x %s", newfile);
    system(chmod);
  \#endif
}} {}
}

Function {saveas_cb()} {return_type void
} {
  code {char *sfa;
sfa = fl_file_chooser("Save File As ?", "*", filename);
if(sfa != NULL) save_file(sfa);} {}
}

Function {save_cb()} {return_type void
} {
  code {if (filename[0] == 0) {
  // No filename
  saveas_cb();
} else {
  save_file(filename);
}} {}
}

Function {open_cb()} {return_type void
} {
  code {if (!check_saved()) return;
char *newfile = fl_file_chooser("Open File ?", "*", filename);
if (newfile != NULL) load_file(newfile);} {}
}

Function {load_file(char *newfile)} {return_type void
} {
  code {bool color_resume = color;
if (color_resume) { // disable color before loading
  color_cb();
}
int lf;
lf = buff->loadfile(newfile);
if (lf) {
  fl_alert("Error while loading file \\'%s\\':\\n%s.", newfile, strerror(errno));
  if (color_resume) color_cb();
} else {
  strcpy(filename, newfile);
  strcpy(title, newfile);
  win->label(title);
  changed = false;
  if (color_resume) color_cb();
}} {}
}

Function {style_unfinished_cb(int, void*)} {return_type void
} {
  comment {call back for highlight data
if style 'A' is found,
this call back will be called.
void *cbArg will be passed as arguement

fl_alert("style_unfinished_cb");} {in_source not_in_header
  }
}

Function {busybox(char *textbuff, char *scanned_text)} {return_type void
} {
  comment {busybox
List of known busybox commands...
https://busybox.net/downloads/BusyBox.html
} {in_source not_in_header
  }
  code {const char *applets[] = {
  "acpid",
  "addgroup",
  "adduser",
  "adjtimex",
  "ar",
  "arp",
  "arping",
  "ash",
  "awk",
  "basename",
  "beep",
  "blkid",
  "brctl",
  "bunzip2",
  "busybox",
  "bzcat",
  "bzip2",
  "cal",
  "cat",
  "catv",
  "chat",
  "chattr",
  "chgrp",
  "chmod",
  "chown",
  "chpasswd",
  "chpst",
  "chroot",
  "chrt",
  "chvt",
  "cksum",
  "clear",
  "cmp",
  "comm",
  "cp",
  "cpio",
  "crond",
  "crontab",
  "cryptpw",
  "cut",
  "date",
  "dc",
  "dd",
  "deallocvt",
  "delgroup",
  "deluser",
  "depmod",
  "devmem",
  "df",
  "dhcprelay",
  "diff",
  "dirname",
  "dmesg",
  "dnsd",
  "dnsdomainname",
  "dos2unix",
  "dpkg",
  "du",
  "dumpkmap",
  "dumpleases",
  "echo",
  "ed",
  "egrep",
  "eject",
  "env",
  "envdir",
  "envuidgid",
  "expand",
  "expr",
  "fakeidentd",
  "false",
  "fbset",
  "fbsplash",
  "fdflush",
  "fdformat",
  "fdisk",
  "fgrep",
  "find",
  "findfs",
  "flash_lock",
  "flash_unlock",
  "fold",
  "free",
  "freeramdisk",
  "fsck",
  "fsck.minix",
  "fsync",
  "ftpd",
  "ftpget",
  "ftpput",
  "fuser",
  "getopt",
  "getty",
  "grep",
  "gunzip",
  "gzip",
  "hd",
  "hdparm",
  "head",
  "hexdump",
  "hostid",
  "hostname",
  "httpd",
  "hush",
  "hwclock",
  "id",
  "ifconfig",
  "ifdown",
  "ifenslave",
  "ifplugd",
  "ifup",
  "inetd",
  "init",
  "inotifyd",
  "insmod",
  "install",
  "ionice",
  "ip",
  "ipaddr",
  "ipcalc",
  "ipcrm",
  "ipcs",
  "iplink",
  "iproute",
  "iprule",
  "iptunnel",
  "kbd_mode",
  "kill",
  "killall",
  "killall5",
  "klogd",
  "last",
  "length",
  "less",
  "linux32",
  "linux64",
  "linuxrc",
  "ln",
  "loadfont",
  "loadkmap",
  "logger",
  "login",
  "logname",
  "logread",
  "losetup",
  "lpd",
  "lpq",
  "lpr",
  "ls",
  "lsattr",
  "lsmod",
  "lzmacat",
  "lzop",
  "lzopcat",
  "makemime",
  "man",
  "md5sum",
  "mdev",
  "mesg",
  "microcom",
  "mkdir",
  "mkdosfs",
  "mkfifo",
  "mkfs.minix",
  "mkfs.vfat",
  "mknod",
  "mkpasswd",
  "mkswap",
  "mktemp",
  "modprobe",
  "more",
  "mount",
  "mountpoint",
  "mt",
  "mv",
  "nameif",
  "nc",
  "netstat",
  "nice",
  "nmeter",
  "nohup",
  "nslookup",
  "od",
  "openvt",
  "passwd",
  "patch",
  "pgrep",
  "pidof",
  "ping",
  "ping6",
  "pipe_progress",
  "pivot_root",
  "pkill",
  "popmaildir",
  "printenv",
  "printf",
  "ps",
  "pscan",
  "pwd",
  "raidautorun",
  "rdate",
  "rdev",
  "readlink",
  "readprofile",
  "realpath",
  "reformime",
  "renice",
  "reset",
  "resize",
  "rm",
  "rmdir",
  "rmmod",
  "route",
  "rpm",
  "rpm2cpio",
  "rtcwake",
  "run-parts",
  "runlevel",
  "runsv",
  "runsvdir",
  "rx",
  "script",
  "scriptreplay",
  "sed",
  "sendmail",
  "seq",
  "setarch",
  "setconsole",
  "setfont",
  "setkeycodes",
  "setlogcons",
  "setsid",
  "setuidgid",
  "sh",
  "sha1sum",
  "sha256sum",
  "sha512sum",
  "showkey",
  "slattach",
  "sleep",
  "softlimit",
  "sort",
  "split",
  "start-stop-daemon",
  "stat",
  "strings",
  "stty",
  "su",
  "sulogin",
  "sum",
  "sv",
  "svlogd",
  "swapoff",
  "swapon",
  "switch_root",
  "sync",
  "sysctl",
  "syslogd",
  "tac",
  "tail",
  "tar",
  "taskset",
  "tcpsvd",
  "tee",
  "telnet",
  "telnetd",
  "test",
  "tftp",
  "tftpd",
  "time",
  "timeout",
  "top",
  "touch",
  "tr",
  "traceroute",
  "true",
  "tty",
  "ttysize",
  "udhcpc",
  "udhcpd",
  "udpsvd",
  "umount",
  "uname",
  "uncompress",
  "unexpand",
  "uniq",
  "unix2dos",
  "unlzma",
  "unlzop",
  "unzip",
  "uptime",
  "usleep",
  "uudecode",
  "uuencode",
  "vconfig",
  "vi",
  "vlock",
  "volname",
  "watch",
  "watchdog",
  "wc",
  "wget",
  "which",
  "who",
  "whoami",
  "xargs",
  "yes",
  "zcat",
  "zcip"
};} {}
  code {/*
compare_keywords(
address_to_buff,
array,
sizeof_array,
address_to_result,
color_style(A~K)
*/
compare_keywords(
  &textbuff[0],
  applets,
  sizeof(applets)/sizeof(*applets),
  &scanned_text[0],
  66
);} {}
}

Function {bourne_builtins(char *textbuff, char *scanned_text)} {open return_type void
} {
  comment {const char *bourne_variables[] = { // List of known bourne shell built-in variables...
  "~",
  "HOME",
  "IFS",
  "OPTARG",
  "OPTIND",
  "PATH",
  "PS1",
  "PS2",
  "PWD",
  "SHLVL"
};
} {in_source not_in_header
  }
  code {// bourne_builtins
const char *bourne_function[] = { // List of known bourne shell built-in functions...
  "alias",
  "break",
  "cd",
  "continue",
  "eval",
  "exec",
  "exit",
  "export",
  "getopts",
  "hash",
  "pwd",
  "read",
  "readonly",
  "return",
  "shift",
  "source",
  "test",
  "times",
  "trap",
  "umask",
  "unset"
};
const char *bourne_constructs[] = { // List of known bourne shell constructs...
  "case",
  "do",
  "done",
  "elif",
  "esac",
  "fi",
  "for",
  "if",
  "in",
  "select",
  "then",
  "until",
  "while"
};} {}
  code {/*
compare_keywords(
address_to_buff,
array,
sizeof_array,
address_to_result,
color_style(A~K)
*/
compare_keywords(
  &textbuff[0],
  bourne_function,
  sizeof(bourne_function)/sizeof(*bourne_function),
  &scanned_text[0],
  68
);
compare_keywords(
  &textbuff[0],
  bourne_constructs,
  sizeof(bourne_constructs)/sizeof(*bourne_constructs),
  &scanned_text[0],
  75
);} {}
}

Function {is_special(char ascii)} {return_type int
} {
  code {// 33~47, 58~64, 91~96, 123~126
if (ascii == 95) {
  // 95 _ usually treated as normal string
  // only exception $_
  // already handled
  return 0;
}
if (ascii > 32 && ascii < 48) {
  return 1;
}
if (ascii > 57 && ascii < 65) {
  return 2;
}
if (ascii > 90 && ascii < 97) {
  return 3;
}
if (ascii > 122 && ascii < 127) {
  return 4;
}
return 0;} {}
  comment {Just a bunch of special characters
Old bloated codes
const char *special_characters[] = {
  "!", // 33
  "\\"", // 34
  "\#", // 35
  "$", // 36
  "%", // 37
  "&", // 38
  "\\'", // 39
  "(", // 40
  ")", // 41
  "*", // 42
  "+", // 43
  ",", // 44
  "-", // 45
  ".", // 46
  "/", // 47
  ":", // 58
  ";", // 59
  "<", // 60
  "=", // 61
  ">", // 62
  "\\?", // 63
  "@", // 64
  "[", // 91
  "\\\\", // 92
  "]", // 93
  "^", // 94
  "_", // 95 usually treated as normal string
  "`", // 96
  "{", // 123
  "|", // 124
  "}" // 125
  "~" // 126 $HOME
};
size_t list_size, prb;
list_size = sizeof(special_characters) / sizeof(*special_characters);

// assign probe
const char *probe;
probe = special_characters[0];

// convert to pointer
const char *cmp;
cmp = &ascii;

for (prb = 0; prb < list_size; prb++) {
  if (strcmp(cmp, probe) == 0) return 1;
  *probe++;
}
return 0;} {in_source not_in_header
  }
}

Function {use_coloring()} {open return_type void
} {
  code {// associate style & buffer
edit->highlight_data(
  stylebuf,
  styletable,
  sizeof(styletable) / sizeof(styletable[0]),
  'A',
  style_unfinished_cb,
  (void*)0
);
// buff->add_modify_callback(style_update, edit);
// buff->add_modify_callback(modification_cb, edit);} {}
}

Function {disable_color()} {return_type void
} {
  code {// buff->remove_modify_callback(modification_cb, edit);
// hopefully disable the style thing
stylebuf->text("");
// edit->highlight_data(NULL, NULL, NULL, NULL, NULL);} {}
}

Function {auto_indent_switch()} {return_type void
} {
  code {auto_indent = !auto_indent;
if (auto_indent) {
  indent_switch->label("No  Indent");
} else {
  indent_switch->label("AutoIndent");
}} {}
}

Function {stylebuf_init()} {open return_type void
} {
  code {// buff_copy
char *buff_copy;
buff_copy = buff->text(); // full copy
int bufflen;
if (buff_copy) {
  bufflen = strlen(buff_copy); // end_pos + 1
} else {
  fl_alert("buff_copy malloc failed");
  return;
}

char *scan;
scan = (char*)malloc(bufflen+1);
if (scan) {
  memset(scan, 65, bufflen); // 'A'
  scan[bufflen] = 0; // '\\0'
} else {
  fl_alert("scan malloc failed");
  free(buff_copy);
  return;
}

/*
// compare keywords
busybox(&buff_copy[0], &scan[0]);
bourne_builtins(&buff_copy[0], &scan[0]);
*/
bool cm = false; // \#comment 35
bool es = false; // \\escapes 92
bool ds = false; // $dolor_sign 36
bool se = false; // ${shell expansion}, ds must be true
bool bq = false; // `back quote command substitution` 96
bool sq = false; // 'single quote' 39
bool dq = false; // "double quote" 34
int cs = 0; // $(command substitution)
int p = 0; // (parentheses) 40 41
// int sb = 0; // [square brackets] 91 93
// int cb = 0; // {curly brackets} 123 125} {}
  code {// Debug
/*
fl_alert("buff_copy:%s", buff_copy);
fl_alert("scan:%s", scan);
*/} {}
  code {// compare keywords
busybox(&buff_copy[0], &scan[0]);
bourne_builtins(&buff_copy[0], &scan[0]);} {}
  code {// Debug
/*
fl_alert("After keyword");
fl_alert("buff_copy:%s", buff_copy);
fl_alert("scan:%s", scan);
*/} {}
  code {int j = 0;

for (;j < bufflen; j++) \{
  switch(buff_copy[j]) \{
    case 10: // newline
      if (cm) cm = !cm;
    case 9: // tab
    case 32: // space
      if (ds) ds = !ds;
      scan[j] = buff_copy[j];
      continue;
    case 35: // \#comment
      if (!ds && !sq && !dq && !se) \{
        cm = true;
        scan[j] = 'J';
      \}
      break;
    case 92: // \\escapes
      if (!cm && !sq) es = true;
      break; // other escape
    case 39: // 'single quote'
      if (cm) break;
      // single quote is always
      // treated literally in double quote
      if (!dq) \{
        sq = !sq;
        scan[j] = 'F';
        continue;
      \}
      break;
    case 34: // "double quote"
      if (cm) break;
      if (!sq) \{
        dq = !dq;
        scan[j] = 'G';
        if (ds) ds = !ds;
        continue;
      \}
      break;
    case 96: // `back quote`
      if (cm || sq) break;
      scan[j] = 'E';
      ds = false;
      bq = !bq;
      break;
    case 36: // $dolor_sign
      if (cm || sq) break;
      ds = true;
      switch(buff_copy[j+1]) \{
        case 33: // built-in variable $!
        case 35: // built-in variable $\#
        case 36: // built-in variable $$
        case 42: // built-in variable $*
        case 45: // built-in variable $-
        case 63: // built-in variable $?
        case 64: // built-in variable $@
        case 95: // built-in variable $_
          scan[j] = 'I';
          j++;
          scan[j] = 'I';
          ds = false;
          continue;
        case 40: // $(...
          cs++;
          p++;
          scan[j] = 'E';
          j++;
          scan[j] = 'E';
          ds = false;
          continue;
        case 123: // shell expansion $\{
          // cb++;
          se = true; // a bit redundant
          scan[j] = 'I';
          j++;
          scan[j] = 'I';
          ds = true;
          continue;
        case 9: // tab
        case 10: // newline
        case 32: // space
        case 47: // regular expression /$/
          // trailing dolor_sign$
          ds = false;
          // resume default
          scan[j] = 'A';
          continue;
      \}
      scan[j] = 'I';
      if (is_special(buff_copy[j+1])) \{
        // invalid variable $, or such
        // resume default
        ds = false;
        scan[j] = 'A';
      \}
      break;
    case 40: // (
      if (cm || sq || dq) break;
      p++;
      scan[j] = 'C';
      break;
    case 41: // )
      if (cm || sq) break;
      if (ds) ds = !ds;
      if (dq) \{
        if (cs == 0)
        break;
      \}
      p--;
      scan[j] = 'C';
      break;
    case 123: // \{
      scan[j] = 'C';
      break;
    case 125: // \}
      if (cm || sq) break;
      if (ds || se) \{
        // end of variable
        ds = false;
        se = false;
        scan[j] = 'I';
        continue;
      \}
      scan[j] = 'C';
      break;
    default:
      if (cm || es || sq) break;
      // scan[j] = 'A'; --> overwrite the keywords
      if (is_special(buff_copy[j])) scan[j] = 'C';
  \}
  if (se) \{
    scan[j] = 'I';
    continue;
  \}
  if (cm) \{
    switch (buff_copy[j]) \{
      case 10: // newline
        cm = false;
      case 9: // tab
      case 32: // space
        scan[j] = buff_copy[j];
        break;
      default:
        scan[j] = 'J';
    \}
    continue;
  \}
  if (sq) \{
    // 'single quote' ignore escapes
    scan[j] = 'F';
    if (buff_copy[j] == 39) sq = !sq;
    continue;
  \}
  if (dq) scan[j] = 'G';
  if (ds) \{
    scan[j] = 'I';
    if (is_special(buff_copy[j+1])) \{
      // end of variable
      ds = false;
      continue;
    \}
  \}
  if (es) \{
    // this char = backslash (92)
    if (buff_copy[j+1]) \{
      // char not null
      scan[j] = 'H';
      scan[j+1] = 'H';
    \}
    if (dq && buff_copy[j+1] == 39) \{
      // echo "\\'" --> \\'
      es = false;
      continue;
    \}
    if (buff_copy[j+1] == 120) \{
      // hex \\xFF 48~57, 65~70, 97~102
      bool hex = ((
        (buff_copy[j+2] > 47 && buff_copy[j+2] < 58) ||
        (buff_copy[j+2] > 64 && buff_copy[j+2] < 71) ||
        (buff_copy[j+2] > 96 && buff_copy[j+2] < 103)
      ) && (
        (buff_copy[j+3] > 47 && buff_copy[j+3] < 58) ||
        (buff_copy[j+3] > 64 && buff_copy[j+3] < 71) ||
        (buff_copy[j+3] > 96 && buff_copy[j+3] < 103)
      ));
      if (hex) \{
        scan[j+2] = 'H';
        scan[j+3] = 'H';
        j+=2;
      \}
    \}
    j++;
    es = false;
    continue;
  \}
  if (cs>0) \{
    if (scan[j] == 'A') scan[j] = 'E';
    if (buff_copy[j] == 41) \{
      // )
      scan[j] = 'E';
      cs--;
      if (p > cs) cs++;
    \}
    // continue;
  \}
  if (bq) \{
    if (scan[j] == 'A') scan[j] = 'E';
    // continue;
  \}
\}} {}
  code {/*
fl_alert("Before init");
fl_alert("buff_copy:%s", buff_copy);
fl_alert("scan:%s", scan);
*/} {}
  code {stylebuf->text(scan);
/*
fl_alert("Write to buff");
fl_alert("%s", stylebuf->text());
*/
free(buff_copy);
free(scan);} {selected
  }
  comment {KeyWord Debug
for (;j < bufflen; j++) {
  switch(buff_copy[j]) {
    case 10: // newline
      if (cm) cm = !cm;
    case 9: // tab
    case 32: // space
      if (ds) ds = !ds;
      scan[j] = buff_copy[j];
  }
}
} {in_source not_in_header
  }
}

Function {color_cb()} {return_type void
} {
  code {color = !color;
if (color) {
  stylebuf_init();
  // scan_forward(0);
  // use_coloring();
  color_switch->label("NoColor");
} else {
  disable_color();
  color_switch->label("Colorful");
  // edit->redisplay_range(0, buff->length());
}
edit->redisplay_range(0, buff->length());} {}
}

Function {auto_indent_cb(int lsp, int pos, char *line)} {return_type int
} {
  comment {lsp: line start pos
pos: insert position
line: entire line
} {in_source not_in_header
  }
  code {int current_pos = pos + 1; // '\\n'
char *indention; // '\\n'space'\\0'
indention = new char[current_pos - lsp]; // [pos - lsp + 1]
int ai = 0;
for (;ai < (current_pos - lsp);ai++) {
  // tab || space
  if (line[ai] == 9 || line[ai] == 32) indention[ai] = line[ai];
  else break;
}
if (ai == 0) {
  if (color) {
    indention[0] = 10; // '\\n'
    indention[0] = 0; // '\\0'
    stylebuf->replace(current_pos, current_pos, indention);
  }
  delete[] indention;
  free(line);
  return current_pos;
}
indention[ai] = 0; // '\\0'
buff->insert(current_pos, indention); // will call modification_cb
// stylebuf is one char slower than buff
current_pos += strlen(indention);
if (color) {
  // modification_cb already handle the inserted '\\n', using "replace"
  stylebuf->replace(pos + 1, current_pos, indention);
}
delete[] indention;
free(line);
return current_pos - 1;} {}
}

Function {compare_keywords(char *text, const char *keys[], int elements, char *result, int ascii)} {return_type void
} {
  comment {old code called after style
int needle_len = strlen(needle);
bool bos = true; // begin of string
while (1) {
  // match first char
  while(*text != *needle) {
    bos = false;
    *text++;
    *result++;
    if (*text == 0) {
      // end of string
      return;
    }
  }
  if (*result == 70 || *result == 71 || *result == 74) {
    // F - Single Quotes
    // G - Double Quotes
    // J - comments
    bos = false;
    *text++;
    *result++;
    continue;
  }
  int nl = 1; // needle[0] already matched
  for (; nl < needle_len; nl++) {
    if (text[nl] != needle[nl]) {
      bos = false;
      *(text += nl);
      *(result += nl);
      break;
    }
  }
  // all matched
  if (nl == needle_len) {
    // check anterior
    if (!bos) {
      // skip begin of string
      switch (*(text - 1)) {
        case 9: // tab
        case 32: // space
        case 38: // &
        case 40: // (
        case 59: // ;
        case 60: // <
        case 62: // >
        case 96: // `
        case 124: // |
          break;
        default:
          *(text += nl);
          *(result += nl);
          continue;
      }
    }
    // check posterior
    switch (text[nl]) {
      case 0: // end of string
      case 9: // tab
      case 10: // newline
      case 32: // space
      case 38: // &
      case 41: // )
      case 59: // ;
      case 60: // <
      case 62: // >
      case 96: // `
      case 124: // |
        break;
      default:
        bos = false;
        *(text += nl);
        *(result += nl);
        continue;
    }
    for (; nl > 0; nl--) {
      *result = ascii;
      *text++;
      *result++;
    }
  }
}} {in_source not_in_header
  }
  comment {old code V2
const char *needle;
bool matched = true;
size_t nl = 0;
size_t textlen = strlen(text);
// matching leading char
size_t i = 0;
for (; i < elements; i++) {
  needle = keys[i];
  nl = strlen(needle);
  if (textlen < nl) {
    // next keyword
    continue;
  }
  // matching first char
  if (*text == *needle) {
    // check posterior
    switch (text[nl]) {
      case 0: // end of string
      case 9: // tab
      case 10: // newline
      case 32: // space
      case 38: // &
      case 41: // )
      case 59: // ;
      case 60: // <
      case 62: // >
      case 96: // `
      case 124: // |
        break;
      default:
        // next keyword
        continue;
    }
    // string length matched
    size_t j = 1; // first char already matched
    for (; j < nl; j++) {
      // matching
      if (text[j] != needle[j]) {
        // next element
        matched = false;
        break;
      }
    }
    if (matched) {
      for (; nl > 0; nl--) {
        *result = ascii;
        textlen--;
        result++;
        text++;
      }
      // breaking element loop
      break;
    }
    // else: stay at current text pos
  }
}
do {
  // check anterior
  switch (*text) {
    case 9: // tab
    case 10: // newline
    case 32: // space
    case 38: // &
    case 40: // (
    case 59: // ;
    case 60: // <
    case 62: // >
    case 96: // `
    case 124: // |
      // if next char is A-Z/a-z
      if (text[1] > 96 && text[1] < 123) {
        // all keywords are in lowercase
        textlen--;
        result++;
        text++;
        break;
      }
    default:
      textlen--;
      result++;
      // *text++ by while
      continue;
  }
  size_t k = 0;
  for (; k < elements; k++) {
    needle = keys[k];
    nl = strlen(needle);
    if (textlen < nl) {
      // next keyword
      continue;
    }
    // matching first char
    if (*text == *needle) {
      // check posterior
      switch (text[nl]) {
        case 0: // end of string
        case 9: // tab
        case 10: // newline
        case 32: // space
        case 38: // &
        case 41: // )
        case 59: // ;
        case 60: // <
        case 62: // >
        case 96: // `
        case 124: // |
          break;
        default:
          // next keyword
          continue;
      }
      matched = true;
      // string length matched
      size_t l = 1; // first char already matched
      for (; l < nl; l++) {
        // matching
        if (text[l] != needle[l]) {
          // next element
          matched = false;
          break;
        }
      }
      if (matched) {
        for (; nl > 0; nl--) {
          *result = ascii;
          textlen--;
          result++;
          text++;
        }
        // stay at current text pos
        textlen++;
        result--;
        text--;
        // breaking element loop
        break;
      }
      // else: stay at current text pos
    }
  }
  textlen--;
  result++;
  // *text++ by while
} while (*text++);} {in_source not_in_header
  }
  code {const char *needle;
bool matched = false;
int loop_nb = 0;
/*
size_t nl; // needle length
size_t textlen = strlen(text);
size_t k;
size_t l;
*/
int nl; // needle length
int textlen = strlen(text);
int k;
int l;

do {
  // check anterior, skip first char
  if (loop_nb) {
    switch (*text) {
      case 9: // tab
      case 10: // newline
      case 32: // space
      case 38: // &
      case 40: // (
      case 59: // ;
      case 60: // <
      case 62: // >
      case 96: // `
      case 124: // |
        // if next char is A-Z/a-z
        if (text[1] > 96 && text[1] < 123) {
          // all keywords are in lowercase
          textlen--;
          result++;
          text++;
          break;
        }
      default:
        textlen--;
        result++;
        // *text++ by while
        continue;
    }
  }
  loop_nb++;
  for (k = 0; k < elements; k++) {
    needle = keys[k];
    nl = strlen(needle);
    if (textlen < nl) {
      // next keyword
      continue;
    }
    // matching first char
    if (*text == *needle) {
      // check posterior
      switch (text[nl]) {
        case 0: // end of string
        case 9: // tab
        case 10: // newline
        case 32: // space
        case 38: // &
        case 41: // )
        case 59: // ;
        case 60: // <
        case 62: // >
        case 96: // `
        case 124: // |
          break;
        default:
          // next keyword
          continue;
      }
      matched = true;
      // string length matched
      // l = 1 --> first char already matched
      for (l = 1; l < nl; l++) {
        // matching
        if (text[l] != needle[l]) {
          // next element
          matched = false;
          break;
        }
      }
      if (matched) {
        for (; nl > 0; nl--) {
          *result = ascii;
          textlen--;
          result++;
          text++;
        }
        // stay at current text pos
        textlen++;
        result--;
        text--;
        // breaking element loop
        break;
      }
      // else: stay at current text pos
    }
  }
  textlen--;
  result++;
  // *text++ by while
} while (*text++);} {}
}

Function {modification_cb(int pos, int nInserted, int nDeleted, int nRestyled, const char *deletedText, void *cbArg)} {open return_type void
} {
  codeblock {if (nInserted == 0 && nDeleted == 0)} {} {
    code {// selection change
stylebuf->unselect();
return;} {}
  }
  codeblock {if (nInserted > 0 && nDeleted > 0)} {} {
    code {// This only happens when a user undo changes
// do nothing...
return;} {}
  }
  codeblock {if (!changed)} {} {
    code {// adjust title
changed = true;
strcat(title, "*");
win->label(title);} {}
  }
  code {// different from pos, a current working pos
int current_pos = pos;} {}
  codeblock {if (auto_indent && nInserted == 1 && buff->char_at(pos) == 10)} {} {
    code {indenting = true;
current_pos = auto_indent_cb(
  buff->line_start(pos),
  pos, // insert position
  buff->line_text(pos)
);
edit->insert_position(current_pos);
return;} {}
  }
  codeblock {if (color)} {open
  } {
    code {// Debug
/*
fl_alert("pos:%d\\nnInserted:%d\\nnDeleted:%d\\nnRestyled:%d\\ndeletedText:\\n%s",
pos, nInserted, nDeleted, nRestyled, deletedText);
fl_alert("current buffer: '%c'\\ncurrent style: '%c' \\ncurrent_pos: '%d'",
buff->char_at(pos), stylebuf->char_at(pos), current_pos);
*/} {}
    code {int scan_pos; // line_start_pos
if (buff->char_at(pos) == 10) {
  scan_pos = pos + 1;
} else {
  scan_pos = buff->line_start(pos);
}} {}
    codeblock {if (indenting)} {open
    } {
      code {indenting = false;
scan_pos = buff->line_start(scan_pos - 2);} {}
    }
    code {// I'm lazy
stylebuf_init();
edit->redisplay_range(0, buff->length());
// edit->redisplay_range(current_pos, buff->length());
edit->insert_position(current_pos);
edit->show_insert_position();
return;} {}
    comment {catch exception} {in_source not_in_header
    }
    codeblock {if (buff->length() != stylebuf->length())} {} {
      code {fl_alert(
  "!!!Exception occur!!!\\nbuff->length = %d\\nstylebuf->length = %d", // \\nForcing reload...",
  buff->length(),
  stylebuf->length()
);
/*
color_cb();
color_cb();
*/} {}
      code {// Debug
fl_alert("pos:%d\\nnInserted:%d\\nnDeleted:%d\\nnRestyled:%d\\ndeletedText:\\n%s",
pos, nInserted, nDeleted, nRestyled, deletedText);
fl_alert("current buffer: '%c'\\ncurrent style: '%c' \\ncurrent_pos: '%d'",
buff->char_at(pos), stylebuf->char_at(pos), current_pos);} {}
    }
  }
}

Function {close_cb(Fl_Widget*, void* v)} {return_type void
} {
  code {if (check_saved()) exit(0);} {}
}

Function {ts_cb()} {return_type void
} {
  code {fl_alert("%d", buff->length());
fl_alert("%s", buff->text());} {}
}

Function {ss_cb()} {return_type void
} {
  code {fl_alert("%d", stylebuf->length());
fl_alert("%s", stylebuf->text());} {}
}

Function {} {open
} {
  Fl_Window win {
    xywh {470 242 425 320} type Double box PLASTIC_UP_BOX hide resizable
  } {
    Fl_Text_Editor edit {
      xywh {1 29 424 288} box PLASTIC_DOWN_FRAME textfont 4 textsize 20 resizable
    }
    Fl_Menu_Bar menu_bar {open
      xywh {0 0 425 30} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX
    } {
      Submenu file_menu {
        label {&File} open
        xywh {0 0 67 24}
      } {
        MenuItem new_bt {
          label {&New File}
          callback {new_cb();}
          xywh {0 0 34 24} shortcut 0x4006e
        }
        MenuItem open {
          label {&Open}
          callback {open_cb();}
          xywh {0 0 100 20} shortcut 0x4006f
        }
        MenuItem save {
          label {&Save}
          callback {save_cb();}
          xywh {0 0 100 20} shortcut 0x40073
        }
        MenuItem saveas {
          label {Save &As}
          callback {saveas_cb();}
          xywh {0 0 34 24} shortcut 0x50073
        }
      }
      Submenu shell_menu {
        label {&Shell} open
        xywh {0 0 67 24}
      } {
        MenuItem sh {
          label {POSIX sh}
          callback {SHELL = "\#!/bin/sh\\n";
  shebang();}
          xywh {0 0 34 24} shortcut 0x80073
        }
        MenuItem bash {
          label {ENV bash}
          callback {SHELL = "\#!/usr/bin/env bash\\n";
  shebang();}
          xywh {0 0 34 24} shortcut 0x80062
        }
        MenuItem plain_text {
          label {Plain text}
          callback {SHELL = "";}
          xywh {0 0 30 20}
        }
      }
      MenuItem color_switch {
        label Colorful
        callback {color_cb();}
        xywh {0 0 67 24}
      }
      MenuItem indent_switch {
        label {Auto Indent}
        callback {auto_indent_switch();}
        xywh {0 0 30 20}
      }
      MenuItem ts_btn {
        label {Text size}
        callback {ts_cb();}
        xywh {0 0 30 20}
      }
      MenuItem ss_btn {
        label {Style size}
        callback {ss_cb();}
        xywh {0 0 30 20}
      }
    }
  }
  code {// editor init
win->label(title);
buffer_init();
use_coloring();
// if (argc > 1) load_file(argv[1]);
win->callback((Fl_Callback *)close_cb, win);} {}
}
