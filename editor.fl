# data file for the Fltk User Interface Designer (fluid)
version 1.0304
header_name {.h}
code_name {.cxx}
comment {author polikuo 2018} {in_source in_header
}

decl {\#include <FL/Fl_Double_Window.H>} {public global
}

decl {\#include <FL/Fl_Text_Editor.H>} {public global
}

decl {\#include <FL/Fl_Menu_Bar.H>} {public global
}

decl {\#include <FL/Fl_Button.H>} {public global
}

decl {\#include <FL/Fl_File_Chooser.H>} {public global
}

decl {\#include <errno.h>} {public global
}

decl {char const *SHELL = "\#!/bin/sh\\n";} {private global
}

decl {char filename[FL_PATH_MAX], title[FL_PATH_MAX];} {private global
}

decl {Fl_Text_Buffer *buff = new Fl_Text_Buffer();} {private global
}

decl {bool color = false;} {private global
}

decl {Fl_Text_Buffer *stylebuf = new Fl_Text_Buffer();} {private global
}

decl {\#define TS 14} {private global
}

comment {Style table
http://www.fltk.org/doc-1.3/Enumerations_8H.html
http://www.fltk.org/doc-1.3/fltk-colormap.png
A - Plain
B - busybox
C - special_characters
D - bourne_function
E - bourne_constructs
F - Single Quotes
G - Double Quotes
H - escapes
I - bourne_variables
J - comments} {in_source not_in_header
}

decl {Fl_Text_Display::Style_Table_Entry styletable[] = {
  { FL_BLACK, FL_COURIER, TS },
  { 82, FL_COURIER_BOLD, TS },
  { FL_DARK3, FL_COURIER,TS },
  { 92, FL_COURIER_BOLD, TS },
  { FL_DARK_GREEN, FL_COURIER, TS },
  { FL_BLUE,FL_COURIER_BOLD, TS },
  { FL_DARK_BLUE, FL_COURIER,TS },
  { FL_DARK_YELLOW, FL_COURIER,TS },
  { FL_DARK_RED, FL_COURIER_BOLD, TS },
  { FL_DARK2, FL_COURIER_ITALIC, TS }
};} {private global
}

Function {buffer_init()} {open return_type void
} {
  code {// attach buffer to  editor
buff->text(SHELL);
edit->buffer(buff);
edit->insert_position(10);
edit->show_insert_position();} {}
}

Function {shebang()} {return_type void
} {
  code {int firstline, current_pos;
current_pos = edit->insert_position();
// search_forward(int startPos, const char *searchString, int *foundPos, int matchCase = 0)
int found = buff->search_forward(0, "\\n", &firstline);
if (found) {
  buff->select(0, firstline+1);
  buff->remove_selection();
  buff->insert(0, SHELL);
  edit->insert_position(current_pos + strlen(SHELL) - firstline - 1);
  edit->show_insert_position();
} else {
  // no newline char
  buff->text(SHELL);
  edit->insert_position(strlen(SHELL));
  edit->show_insert_position();
}} {}
}

Function {new_cb()} {open return_type void
} {
  code {// coloring
if (color) {
  color_cb(); // called twice
  buff->text(SHELL);
  color_cb(); // to refresh
} else {
  buff->text(SHELL);
}
edit->insert_position(strlen(SHELL));
edit->show_insert_position();
strcpy(filename, "");
strcpy(title, "");
win->label(title);} {}
}

Function {save_file(const char *newfile)} {return_type void
} {
  code {// Save file
// auto append trailing "\\n"
int buff_end;
buff_end = buff->length();
char last_char;
last_char = buff->char_at(buff_end - 1);
if (last_char != 10) {
  buff->append("\\n");
  edit->insert_position(buff_end + 1);
  edit->show_insert_position();
}
// fl_alert("Saving to file %s", newfile);
if (buff->savefile(newfile)) {
  fl_alert("Error writing to file \\'%s\\':\\n%s.", newfile, strerror(errno));
} else {
  strcpy(filename, newfile);
  strcpy(title, newfile);
  win->label(title);
  \#ifdef __linux__
    char chmod[FL_PATH_MAX + 9];
    sprintf(chmod, "chmod +x %s", newfile);
    system(chmod);
  \#endif
}} {}
}

Function {saveas_cb()} {return_type void
} {
  code {char *sfa;
sfa = fl_file_chooser("Save File As ?", "*", filename);
if(sfa != NULL) save_file(sfa);} {}
}

Function {save_cb()} {return_type void
} {
  code {if (filename[0] == 0) {
  // No filename
  saveas_cb();
} else {
  save_file(filename);
}} {}
}

Function {open_cb()} {return_type void
} {
  code {char *newfile = fl_file_chooser("Open File ?", "*", filename);
if (newfile != NULL) load_file(newfile);} {}
}

Function {load_file(char *newfile)} {open return_type void
} {
  code {if (color) { // disable color
  disable_color();
  color_switch->label("Colorful");
  edit->redisplay_range(0, buff->length());
}
int lf;
lf = buff->loadfile(newfile);
if (lf) {
  fl_alert("Error while loading file \\'%s\\':\\n%s.", newfile, strerror(errno));
  if (color) {
    stylebuf_init();
    use_coloring();
    color_switch->label("NoColor");
  }
} else {
  strcpy(filename, newfile);
  strcpy(title, newfile);
  win->label(title);
  if (color) {
    stylebuf_init();
    use_coloring();
    color_switch->label("NoColor");
  }
}} {}
}

Function {style_unfinished_cb(int, void*)} {return_type void
} {
  comment {call back for highlight data
if style 'A' is found,
this call back will be called.
void *cbArg will be passed as arguement

fl_alert("style_unfinished_cb");} {in_source not_in_header
  }
}

Function {busybox(int line_start)} {open return_type void
} {
  comment {busybox
List of known busybox commands...
https://busybox.net/downloads/BusyBox.html
} {in_source not_in_header
  }
  code {const char *applets[] = {
  "acpid",
  "addgroup",
  "adduser",
  "adjtimex",
  "ar",
  "arp",
  "arping",
  "ash",
  "awk",
  "basename",
  "beep",
  "blkid",
  "brctl",
  "bunzip2",
  "busybox",
  "bzcat",
  "bzip2",
  "cal",
  "cat",
  "catv",
  "chat",
  "chattr",
  "chgrp",
  "chmod",
  "chown",
  "chpasswd",
  "chpst",
  "chroot",
  "chrt",
  "chvt",
  "cksum",
  "clear",
  "cmp",
  "comm",
  "cp",
  "cpio",
  "crond",
  "crontab",
  "cryptpw",
  "cut",
  "date",
  "dc",
  "dd",
  "deallocvt",
  "delgroup",
  "deluser",
  "depmod",
  "devmem",
  "df",
  "dhcprelay",
  "diff",
  "dirname",
  "dmesg",
  "dnsd",
  "dnsdomainname",
  "dos2unix",
  "dpkg",
  "du",
  "dumpkmap",
  "dumpleases",
  "echo",
  "ed",
  "egrep",
  "eject",
  "env",
  "envdir",
  "envuidgid",
  "expand",
  "expr",
  "fakeidentd",
  "false",
  "fbset",
  "fbsplash",
  "fdflush",
  "fdformat",
  "fdisk",
  "fgrep",
  "find",
  "findfs",
  "flash_lock",
  "flash_unlock",
  "fold",
  "free",
  "freeramdisk",
  "fsck",
  "fsck.minix",
  "fsync",
  "ftpd",
  "ftpget",
  "ftpput",
  "fuser",
  "getopt",
  "getty",
  "grep",
  "gunzip",
  "gzip",
  "hd",
  "hdparm",
  "head",
  "hexdump",
  "hostid",
  "hostname",
  "httpd",
  "hush",
  "hwclock",
  "id",
  "ifconfig",
  "ifdown",
  "ifenslave",
  "ifplugd",
  "ifup",
  "inetd",
  "init",
  "inotifyd",
  "insmod",
  "install",
  "ionice",
  "ip",
  "ipaddr",
  "ipcalc",
  "ipcrm",
  "ipcs",
  "iplink",
  "iproute",
  "iprule",
  "iptunnel",
  "kbd_mode",
  "kill",
  "killall",
  "killall5",
  "klogd",
  "last",
  "length",
  "less",
  "linux32",
  "linux64",
  "linuxrc",
  "ln",
  "loadfont",
  "loadkmap",
  "logger",
  "login",
  "logname",
  "logread",
  "losetup",
  "lpd",
  "lpq",
  "lpr",
  "ls",
  "lsattr",
  "lsmod",
  "lzmacat",
  "lzop",
  "lzopcat",
  "makemime",
  "man",
  "md5sum",
  "mdev",
  "mesg",
  "microcom",
  "mkdir",
  "mkdosfs",
  "mkfifo",
  "mkfs.minix",
  "mkfs.vfat",
  "mknod",
  "mkpasswd",
  "mkswap",
  "mktemp",
  "modprobe",
  "more",
  "mount",
  "mountpoint",
  "mt",
  "mv",
  "nameif",
  "nc",
  "netstat",
  "nice",
  "nmeter",
  "nohup",
  "nslookup",
  "od",
  "openvt",
  "passwd",
  "patch",
  "pgrep",
  "pidof",
  "ping",
  "ping6",
  "pipe_progress",
  "pivot_root",
  "pkill",
  "popmaildir",
  "printenv",
  "printf",
  "ps",
  "pscan",
  "pwd",
  "raidautorun",
  "rdate",
  "rdev",
  "readlink",
  "readprofile",
  "realpath",
  "reformime",
  "renice",
  "reset",
  "resize",
  "rm",
  "rmdir",
  "rmmod",
  "route",
  "rpm",
  "rpm2cpio",
  "rtcwake",
  "run-parts",
  "runlevel",
  "runsv",
  "runsvdir",
  "rx",
  "script",
  "scriptreplay",
  "sed",
  "sendmail",
  "seq",
  "setarch",
  "setconsole",
  "setfont",
  "setkeycodes",
  "setlogcons",
  "setsid",
  "setuidgid",
  "sh",
  "sha1sum",
  "sha256sum",
  "sha512sum",
  "showkey",
  "slattach",
  "sleep",
  "softlimit",
  "sort",
  "split",
  "start-stop-daemon",
  "stat",
  "strings",
  "stty",
  "su",
  "sulogin",
  "sum",
  "sv",
  "svlogd",
  "swapoff",
  "swapon",
  "switch_root",
  "sync",
  "sysctl",
  "syslogd",
  "tac",
  "tail",
  "tar",
  "taskset",
  "tcpsvd",
  "tee",
  "telnet",
  "telnetd",
  "test",
  "tftp",
  "tftpd",
  "time",
  "timeout",
  "top",
  "touch",
  "tr",
  "traceroute",
  "true",
  "tty",
  "ttysize",
  "udhcpc",
  "udhcpd",
  "udpsvd",
  "umount",
  "uname",
  "uncompress",
  "unexpand",
  "uniq",
  "unix2dos",
  "unlzma",
  "unlzop",
  "unzip",
  "uptime",
  "usleep",
  "uudecode",
  "uuencode",
  "vconfig",
  "vi",
  "vlock",
  "volname",
  "watch",
  "watchdog",
  "wc",
  "wget",
  "which",
  "who",
  "whoami",
  "xargs",
  "yes",
  "zcat",
  "zcip"
};} {}
}

Function {is_special(char ascii)} {return_type int
} {
  code {// 33~47, 58~64, 91~96, 123~126
if (ascii == 95) {
  // 95 _ usually treated as normal string
  // only exception $_
  // already handled
  return 0;
}
if (ascii > 32 && ascii < 48) {
  return 1;
}
if (ascii > 57 && ascii < 65) {
  return 2;
}
if (ascii > 90 && ascii < 97) {
  return 3;
}
if (ascii > 122 && ascii < 127) {
  return 4;
}
return 0;} {}
  comment {Just a bunch of special characters
Old bloated codes
const char *special_characters[] = {
  "!", // 33
  "\\"", // 34
  "\#", // 35
  "$", // 36
  "%", // 37
  "&", // 38
  "\\'", // 39
  "(", // 40
  ")", // 41
  "*", // 42
  "+", // 43
  ",", // 44
  "-", // 45
  ".", // 46
  "/", // 47
  ":", // 58
  ";", // 59
  "<", // 60
  "=", // 61
  ">", // 62
  "\\?", // 63
  "@", // 64
  "[", // 91
  "\\\\", // 92
  "]", // 93
  "^", // 94
  "_", // 95 usually treated as normal string
  "`", // 96
  "{", // 123
  "|", // 124
  "}" // 125
  "~" // 126 $HOME
};
size_t list_size, prb;
list_size = sizeof(special_characters) / sizeof(*special_characters);

// assign probe
const char *probe;
probe = special_characters[0];

// convert to pointer
const char *cmp;
cmp = &ascii;

for (prb = 0; prb < list_size; prb++) {
  if (strcmp(cmp, probe) == 0) return 1;
  *probe++;
}
return 0;} {in_source not_in_header
  }
}

Function {stylebuf_init()} {open return_type void
} {
  code {// shebang style
char *style_init;
style_init = new char[buff->length() + 1];
int j = buff->line_end(0);
memset(style_init, 'J', j);
style_init[j] = 10; // newline} {}
  comment {sh syntax notes:
X=something
echo $X ----> something
echo $X\# ---> something\#
echo "\\" ---> unterminated quoted string
echo "\\'" --> \\' single quote in double quote does not escape
echo '\\' ---> \\ treated literal
echo '\\'' --> unterminated quoted string
echo "'"' --> looking for matching '
echo '"'"' -> looking for matching "
echo "'"'"' > '"
echo '"'"'" > "'
possible combination:
both T should never happens
sq = F, dq = F;
sq = T, dq = F;
sq = F, dq = T;
style 'S': invisible chars
} {in_source not_in_header
  }
  code {// get a copy of current buffer
char *buff_copy;
buff_copy = buff->text();

bool cm = false; // \#comment 35
bool es = false; // \\escapes 92
bool ds = false; // $dolor_sign 36
bool se = false; // $\{shell expansion\}, ds must be true
bool bq = false; // `back quote command substitution` 96
bool sq = false; // 'single quote' 39
bool dq = false; // "double quote" 34
int cs = 0; // $(command substitution)
int p = 0; // (parentheses) 40 41
// int sb = 0; // [square brackets] 91 93
// int cb = 0; // \{curly brackets\} 123 125

for (;j < buff->length(); j++) \{
  switch(buff_copy[j]) \{
    case 10: // newline
      if (cm) cm = !cm;
    case 9: // tab
    case 32: // space
      if (ds) ds = !ds;
      style_init[j] = buff_copy[j];
      continue;
    case 35: // \#comment
      if (!ds && !sq && !dq && !se) \{
        cm = true;
        style_init[j] = 'J';
      \}
      break;
    case 92: // \\escapes
      if (cm || sq) break;
      es = true;
      break; // other escape
    case 39: // 'single quote'
      if (cm) break;
      // single quote is always
      // treated literally in double quote
      if (!dq) \{
        sq = !sq;
        style_init[j] = 'F';
        continue;
      \}
      break;
    case 34: // "double quote"
      if (cm) break;
      if (!sq) \{
        dq = !dq;
        style_init[j] = 'G';
        if (ds) ds = !ds;
        continue;
      \}
      break;
    case 96: // `back quote`
      if (cm || sq) break;
      style_init[j] = 'E';
      ds = false;
      bq = !bq;
      break;
    case 36: // $dolor_sign
      if (cm || sq) break;
      ds = true;
      switch(buff_copy[j+1]) \{
        case 33: // built-in variable $!
        case 35: // built-in variable $\#
        case 36: // built-in variable $$
        case 42: // built-in variable $*
        case 45: // built-in variable $-
        case 63: // built-in variable $?
        case 64: // built-in variable $@
        case 95: // built-in variable $_
          style_init[j] = 'I';
          j++;
          style_init[j] = 'I';
          ds = false;
          continue;
        case 40: // $(...
          cs++;
          p++;
          style_init[j] = 'E';
          j++;
          style_init[j] = 'E';
          ds = false;
          continue;
        case 123: // shell expansion $\{
          // cb++;
          se = true; // a bit redundant
          style_init[j] = 'I';
          j++;
          style_init[j] = 'I';
          ds = true;
          continue;
        case 9: // tab
        case 10: // newline
        case 32: // space
        case 47: // regular expression /$/
          // trailing dolor_sign$
          ds = false;
          // use default
          style_init[j] = 'A';
          continue;
      \}
      style_init[j] = 'I';
      if (is_special(buff_copy[j+1])) \{
        // invalid variable $, or such
        ds = false;
        style_init[j] = 'A';
      \}
      break;
    case 40: // (
      if (cm || sq || dq) break;
      p++;
      style_init[j] = 'C';
      break;
    case 41: // )
      if (cm || sq) break;
      if (ds) ds = !ds;
      if (dq) \{
        if (cs == 0)
        break;
      \}
      p--;
      style_init[j] = 'C';
      break;
    case 123: // \{
      style_init[j] = 'C';
      break;
    case 125: // \}
      if (cm || sq) break;
      if (ds || se) \{
        // end of variable
        ds = false;
        se = false;
        style_init[j] = 'I';
        continue;
      \}
      style_init[j] = 'C';
      break;
    default:
      if (cm || es || sq) break;
      style_init[j] = 'A';
      if (is_special(buff_copy[j])) style_init[j] = 'C';
  \}
  if (se) \{
    style_init[j] = 'I';
    continue;
  \}
  if (cm) \{
    switch (buff_copy[j]) \{
      case 10: // newline
        cm = false;
      case 9: // tab
      case 32: // space
        style_init[j] = buff_copy[j];
        break;
      default:
        style_init[j] = 'J';
    \}
    continue;
  \}
  if (sq) \{
    // 'single quote' ignore escapes
    style_init[j] = 'F';
    if (buff_copy[j] == 39) sq = !sq;
    continue;
  \}
  if (dq) style_init[j] = 'G';
  if (ds) \{
    style_init[j] = 'I';
    if (is_special(buff_copy[j+1])) \{
      // end of variable
      ds = false;
      continue;
    \}
  \}
  if (es) \{
    // this char = backslash (92)
    if (buff_copy[j+1]) \{
      // char not null
      style_init[j] = 'H';
      style_init[j+1] = 'H';
    \}
    if (dq && buff_copy[j+1] == 39) \{
      /* echo "\\'" --> \\' */
      es = false;
      continue;
    \}
    if (buff_copy[j+1] == 120) \{
      // hex \\xFF 48~57, 65~70, 97~102
      bool hex = ((
        (buff_copy[j+2] > 47 && buff_copy[j+2] < 58) ||
        (buff_copy[j+2] > 64 && buff_copy[j+2] < 71) ||
        (buff_copy[j+2] > 96 && buff_copy[j+2] < 103)
      ) && (
        (buff_copy[j+3] > 47 && buff_copy[j+3] < 58) ||
        (buff_copy[j+3] > 64 && buff_copy[j+3] < 71) ||
        (buff_copy[j+3] > 96 && buff_copy[j+3] < 103)
      ));
      if (hex) \{
        style_init[j+2] = 'H';
        style_init[j+3] = 'H';
        j+=2;
      \}
    \}
    j++;
    es = false;
    continue;
  \}
  if (cs>0) \{
    style_init[j] = 'E';
    if (ds) style_init[j] = 'I';
    if (buff_copy[j] == 41) \{
      // )
      style_init[j] = 'E';
      cs--;
      if (p > cs) cs++;
    \}
    // continue;
  \}
  if (bq) \{
    style_init[j] = 'E';
    // continue;
  \}
\}} {}
  code {// write to buffer and free
style_init[buff->length()] = 0; // '\\0'
stylebuf->text(style_init);
delete[] style_init;
// newly allocated text buffer - must be free'd
free(buff_copy);} {}
}

Function {use_coloring()} {open return_type void
} {
  code {// bourne_builtins
const char *bourne_function[] = { // List of known bourne shell built-in functions...
  "alias",
  "break",
  "cd",
  "continue",
  "eval",
  "exec",
  "exit",
  "export",
  "getopts",
  "hash",
  "pwd",
  "readonly",
  "return",
  "shift",
  "source",
  "test",
  "times",
  "trap",
  "umask",
  "unset"
};
const char *bourne_constructs[] = { // List of known bourne shell constructs...
  "case",
  "do",
  "done",
  "elif",
  "esac",
  "fi",
  "for",
  "if",
  "in",
  "select",
  "then",
  "until",
  "while"
};
const char *bourne_variables[] = { // List of known bourne shell built-in variables...
  "~",
  "HOME",
  "IFS",
  "OPTARG",
  "OPTIND",
  "PATH",
  "PS1",
  "PS2",
  "PWD",
  "SHLVL"
};} {}
  code {// associate style & buffer
edit->highlight_data(
  stylebuf,
  styletable,
  sizeof(styletable) / sizeof(styletable[0]),
  'A',
  style_unfinished_cb,
  (void*)0
);
// buff->add_modify_callback(style_update, edit);
buff->add_modify_callback(modification_cb, edit);} {}
}

Function {disable_color()} {return_type void
} {
  code {buff->remove_modify_callback(modification_cb, edit);
// hopefully disable the style thing
stylebuf->text("");
// edit->highlight_data(NULL, NULL, NULL, NULL, NULL);} {}
}

Function {color_cb()} {open return_type void
} {
  code {color = !color;
if (color) {
  stylebuf_init();
  use_coloring();
  color_switch->label("NoColor");
} else {
  disable_color();
  color_switch->label("Colorful");
  edit->redisplay_range(0, buff->length());
}} {}
}

Function {auto_indent_cb(int lsp, int pos, char *line)} {open return_type int
} {
  comment {lsp: line start pos
pos: insert position
line: entire line
} {in_source not_in_header
  }
  code {int current_pos = pos + 1; // '\\n'
char *indention; // '\\n'space'\\0'
indention = new char[current_pos - lsp]; // [pos - lsp + 1]
int ai = 0;
for (;ai < (current_pos - lsp);ai++) {
  // tab || space
  if (line[ai] == 9 || line[ai] == 32) indention[ai] = line[ai];
  else break;
}
if (ai == 0) {
  indention[0] = 10; // '\\n'
  indention[0] = 0; // '\\0'
  stylebuf->replace(current_pos, current_pos, indention);
  delete[] indention;
  free(line);
  return current_pos;
}
indention[ai] = 0; // '\\0'
buff->insert(current_pos, indention); // will call modification_cb
// stylebuf is one char slower than buff
current_pos += strlen(indention);
stylebuf->replace(pos + 1, current_pos, indention);
// modification_cb already handle the inserted '\\n', using "replace"
delete[] indention;
free(line);
return current_pos - 1;} {}
}

Function {modification_cb(int pos, int nInserted, int nDeleted, int nRestyled, const char *deletedText, void *cbArg)} {open return_type void
} {
  code {int current_pos = pos;
// different from pos, a current working pos
// selection change
if (nInserted == 0 && nDeleted == 0) {
  stylebuf->unselect();
  return;
}
// get a copy of current buffer
char *style_copy;
style_copy = stylebuf->text();} {}
  code {// Debug
/*
fl_alert("pos:%d\\nnInserted:%d\\nnDeleted:%d\\nnRestyled:%d\\ndeletedText:\\n%s",
pos, nInserted, nDeleted, nRestyled, deletedText);
fl_alert("current buffer: '%c'\\ncurrent style: '%c' \\ncurrent_pos: '%d'",
buff->char_at(pos), stylebuf->char_at(pos), current_pos);
*/} {}
  comment {Insertion / deletion
if (nInserted > 0) {
  char *cacheIN;
  cacheIN = new char[nInserted+1];
  memset(cacheIN, 'A', nInserted);
  cacheIN[nInserted] = 0; // '\\0'
  stylebuf->replace(current_pos, current_pos + nDeleted, cacheIN);
  delete[] cacheIN;
} else {
  stylebuf->remove(pos, pos + nDeleted);
}} {in_source not_in_header
  }
  codeblock {if (nInserted > 1)} {open
  } {
    code {char *cacheIN;
cacheIN = new char[nInserted+1];
memset(cacheIN, 'A', nInserted);
if (style_copy[pos-1] == 'F' && style_copy[pos] == 'F') {
  // between single quotes
  memset(cacheIN, 'F', nInserted);
}
cacheIN[nInserted] = 0; // '\\0'
// stylebuf->replace(current_pos, current_pos + nDeleted, cacheIN);
stylebuf->replace(current_pos, current_pos, cacheIN);
delete[] cacheIN;} {}
  }
  codeblock {if (nInserted == 1)} {open
  } {
    code {char *cacheIN;
cacheIN = new char[2];
cacheIN[0] = buff->char_at(pos); // original char
cacheIN[1] = 0; // '\\0'
bool auto_indent = false;
bool sf = true;
switch (cacheIN[0]) {
  case 9:
  case 32:
    break; // original char
  case 10:
    // newline auto indent
    auto_indent = true;
    break; // original char
  default:
    if (style_copy[pos-1] == 'F'&& style_copy[pos] == 'F') {
      // between single quotes
      cacheIN[0] = 'F';
      sf = false;
    } else {
      cacheIN[0] = 'A';
    }
}
stylebuf->insert(pos, cacheIN);
if (auto_indent) {
  current_pos = auto_indent_cb(
    buff->line_start(pos),
    pos, // insert position
    buff->line_text(pos)
  );
}
free(cacheIN);
if (sf) {
  scan_forward(pos);
}} {}
  }
  codeblock {if (nInserted == 0)} {open
  } {
    code {stylebuf->remove(pos, pos + nDeleted);} {}
    comment {single quotes
'str' --> 'st' ==> just delete
'str' --> st':
rescan style of "st"
copy the style before it
possible style: A,B,C,D,E
reset every style after '} {in_source not_in_header
    }
  }
  code {edit->insert_position(current_pos);
edit->show_insert_position();
free(style_copy);} {}
  comment {catch exception} {in_source not_in_header
  }
  codeblock {if (buff->length() != stylebuf->length())} {open
  } {
    code {fl_alert(
  "!!!Exception occur!!!\\nbuff->length = %d\\nstylebuf->length = %d\\nForcing reload...",
  buff->length(),
  stylebuf->length()
);
color_cb();
color_cb();} {}
  }
  codeblock {if (nInserted > 0 && nDeleted > 0)} {} {
    code {fl_alert("!!!Exception occur!!!\\nnInserted > 0 && nDeleted > 0");} {}
  }
  code {// Debug
/*
fl_alert("pos:%d\\nnInserted:%d\\nnDeleted:%d\\nnRestyled:%d\\ndeletedText:\\n%s",
pos, nInserted, nDeleted, nRestyled, deletedText);
fl_alert("current buffer: '%c'\\ncurrent style: '%c' \\ncurrent_pos: '%d'",
buff->char_at(pos), stylebuf->char_at(pos), current_pos);
*/} {}
}

Function {ts_cb()} {return_type void
} {
  code {fl_alert("%d", buff->length());
fl_alert("%s", buff->text());} {}
}

Function {ss_cb()} {return_type void
} {
  code {fl_alert("%d", stylebuf->length());
fl_alert("%s", stylebuf->text());} {}
}

Function {} {open
} {
  Fl_Window win {open
    xywh {470 242 425 320} type Double box PLASTIC_UP_BOX hide resizable
  } {
    Fl_Text_Editor edit {
      xywh {1 29 424 288} box PLASTIC_DOWN_FRAME textfont 4 textsize 20 resizable
    }
    Fl_Menu_Bar menu_bar {
      xywh {0 0 425 30} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX
    } {
      Submenu file_menu {
        label {&File}
        xywh {0 0 67 24}
      } {
        MenuItem new_bt {
          label {&New File}
          callback {new_cb();}
          xywh {0 0 34 24} shortcut 0x4006e
        }
        MenuItem open {
          label {&Open}
          callback {open_cb();}
          xywh {0 0 100 20} shortcut 0x4006f
        }
        MenuItem save {
          label {&Save}
          callback {save_cb();}
          xywh {0 0 100 20} shortcut 0x40073
        }
        MenuItem saveas {
          label {Save &As}
          callback {saveas_cb();}
          xywh {0 0 34 24} shortcut 0x50073
        }
      }
      Submenu shell_menu {
        label {&Shell}
        xywh {0 0 67 24}
      } {
        MenuItem sh {
          label {POSIX sh}
          callback {SHELL = "\#!/bin/sh\\n";
  shebang();}
          xywh {0 0 34 24} shortcut 0x80073
        }
        MenuItem bash {
          label {ENV bash}
          callback {SHELL = "\#!/usr/bin/env bash\\n";
  shebang();}
          xywh {0 0 34 24} shortcut 0x80062
        }
      }
      MenuItem color_switch {
        label Colorful
        callback {color_cb();}
        xywh {0 0 67 24}
      }
      MenuItem ts_btn {
        label {Text size}
        callback {ts_cb();}
        xywh {0 0 30 20}
      }
      MenuItem ss_btn {
        label {Style size}
        callback {ss_cb();}
        xywh {0 0 30 20}
      }
    }
  }
  code {// editor init
win->label(title);
buffer_init();
// if (argc > 1) load_file(argv[1]);} {}
}

Function {scan_forward(int pos)} {open
} {
  code {int line_start = buff->line_start(pos);
// int line_end = buff->line_end(pos);
char *result;
result = new char[buff->length() - line_start + 1];
char *buff_copy;
buff_copy = buff->text_range(line_start, buff->length()-1);
// int s = 0;
// char *scan = buff_copy[0];

bool cm = false; // \#comment 35
bool es = false; // \\escapes 92
bool ds = false; // $dolor_sign 36
bool se = false; // $\{shell expansion\}, ds must be true
bool bq = false; // `back quote command substitution` 96
bool sq = false; // 'single quote' 39
bool dq = false; // "double quote" 34
int cs = 0; // $(command substitution)
int p = 0; // (parentheses) 40 41
// int sb = 0; // [square brackets] 91 93
// int cb = 0; // \{curly brackets\} 123 125
/* while (*buff_copy) do ...
for (;s < strlen(buff_copy);s++) \{
\}
but can it be free'd after moving it till the end ?
*/
int j = line_start;
// while (*scan++) \{
for (;j < buff->length(); j++) \{
  switch(buff_copy[j]) \{
    case 10: // newline
      fl_alert("Newline:%s", buff->line_text(j));
      /*
      V1: scan beforehand
      line_start = j + 1;
      line_end = buff->line_end(j + 1);
      V2: scan afterward
      line_start = buff->line_start(j - 1);
      line_end = j - 1;
      */
      if (cm) cm = !cm;
    case 9: // tab
    case 32: // space
      if (ds) ds = !ds;
      result[j] = buff_copy[j];
      continue;
    case 35: // \#comment
      if (!ds && !sq && !dq && !se) \{
        cm = true;
        result[j] = 'J';
      \}
      break;
    case 92: // \\escapes
      if (cm || sq) break;
      es = true;
      break; // other escape
    case 39: // 'single quote'
      if (cm) break;
      // single quote is always
      // treated literally in double quote
      if (!dq) \{
        sq = !sq;
        result[j] = 'F';
        continue;
      \}
      break;
    case 34: // "double quote"
      if (cm) break;
      if (!sq) \{
        dq = !dq;
        result[j] = 'G';
        if (ds) ds = !ds;
        continue;
      \}
      break;
    case 96: // `back quote`
      if (cm || sq) break;
      result[j] = 'E';
      ds = false;
      bq = !bq;
      break;
    case 36: // $dolor_sign
      if (cm || sq) break;
      ds = true;
      switch(buff_copy[j+1]) \{
        case 33: // built-in variable $!
        case 35: // built-in variable $\#
        case 36: // built-in variable $$
        case 42: // built-in variable $*
        case 45: // built-in variable $-
        case 63: // built-in variable $?
        case 64: // built-in variable $@
        case 95: // built-in variable $_
          result[j] = 'I';
          j++;
          result[j] = 'I';
          ds = false;
          continue;
        case 40: // $(...
          cs++;
          p++;
          result[j] = 'E';
          j++;
          result[j] = 'E';
          ds = false;
          continue;
        case 123: // shell expansion $\{
          // cb++;
          se = true; // a bit redundant
          result[j] = 'I';
          j++;
          result[j] = 'I';
          ds = true;
          continue;
        case 9: // tab
        case 10: // newline
        case 32: // space
        case 47: // regular expression /$/
          // trailing dolor_sign$
          ds = false;
          // use default
          result[j] = 'A';
          continue;
      \}
      result[j] = 'I';
      if (is_special(buff_copy[j+1])) \{
        // invalid variable $, or such
        ds = false;
        result[j] = 'A';
      \}
      break;
    case 40: // (
      if (cm || sq || dq) break;
      p++;
      result[j] = 'C';
      break;
    case 41: // )
      if (cm || sq) break;
      if (ds) ds = !ds;
      if (dq) \{
        if (cs == 0)
        break;
      \}
      p--;
      result[j] = 'C';
      break;
    case 123: // \{
      result[j] = 'C';
      break;
    case 125: // \}
      if (cm || sq) break;
      if (ds || se) \{
        // end of variable
        ds = false;
        se = false;
        result[j] = 'I';
        continue;
      \}
      result[j] = 'C';
      break;
    default:
      if (cm || es || sq) break;
      result[j] = 'A';
      if (is_special(buff_copy[j])) result[j] = 'C';
  \}
  if (se) \{
    result[j] = 'I';
    continue;
  \}
  if (cm) \{
    switch (buff_copy[j]) \{
      case 10: // newline
        cm = false;
      case 9: // tab
      case 32: // space
        result[j] = buff_copy[j];
        break;
      default:
        result[j] = 'J';
    \}
    continue;
  \}
  if (sq) \{
    // 'single quote' ignore escapes
    result[j] = 'F';
    if (buff_copy[j] == 39) sq = !sq;
    continue;
  \}
  if (dq) result[j] = 'G';
  if (ds) \{
    result[j] = 'I';
    if (is_special(buff_copy[j+1])) \{
      // end of variable
      ds = false;
      continue;
    \}
  \}
  if (es) \{
    // this char = backslash (92)
    if (buff_copy[j+1]) \{
      // char not null
      result[j] = 'H';
      result[j+1] = 'H';
    \}
    if (dq && buff_copy[j+1] == 39) \{
      /* echo "\\'" --> \\' */
      es = false;
      continue;
    \}
    if (buff_copy[j+1] == 120) \{
      // hex \\xFF 48~57, 65~70, 97~102
      bool hex = ((
        (buff_copy[j+2] > 47 && buff_copy[j+2] < 58) ||
        (buff_copy[j+2] > 64 && buff_copy[j+2] < 71) ||
        (buff_copy[j+2] > 96 && buff_copy[j+2] < 103)
      ) && (
        (buff_copy[j+3] > 47 && buff_copy[j+3] < 58) ||
        (buff_copy[j+3] > 64 && buff_copy[j+3] < 71) ||
        (buff_copy[j+3] > 96 && buff_copy[j+3] < 103)
      ));
      if (hex) \{
        result[j+2] = 'H';
        result[j+3] = 'H';
        j+=2;
      \}
    \}
    j++;
    es = false;
    continue;
  \}
  if (cs>0) \{
    result[j] = 'E';
    if (ds) result[j] = 'I';
    if (buff_copy[j] == 41) \{
      // )
      result[j] = 'E';
      cs--;
      if (p > cs) cs++;
    \}
    // continue;
  \}
  if (bq) \{
    result[j] = 'E';
    // continue;
  \}
  // *scan++;
\}

free(buff_copy);} {selected
  }
}
