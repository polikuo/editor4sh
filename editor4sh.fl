# data file for the Fltk User Interface Designer (fluid)
version 1.0304
header_name {.h}
code_name {.cxx}
comment {author polikuo 2018} {in_source in_header
}

decl {\#include <FL/Fl_Double_Window.H>} {public global
}

decl {\#include <FL/Fl_Text_Editor.H>} {public global
}

decl {\#include <FL/Fl_Menu_Bar.H>} {public global
}

decl {\#include <FL/Fl_Button.H>} {public global
}

decl {\#include <FL/Fl_File_Chooser.H>} {public global
}

decl {\#include <errno.h>} {public global
}

comment {busybox
List of known busybox commands...
https://busybox.net/downloads/BusyBox.html
} {not_in_source in_header
}

decl {const char *applets[] = {
  "acpid",
  "addgroup",
  "adduser",
  "adjtimex",
  "ar",
  "arp",
  "arping",
  "ash",
  "awk",
  "basename",
  "beep",
  "blkid",
  "brctl",
  "bunzip2",
  "busybox",
  "bzcat",
  "bzip2",
  "cal",
  "cat",
  "catv",
  "chat",
  "chattr",
  "chgrp",
  "chmod",
  "chown",
  "chpasswd",
  "chpst",
  "chroot",
  "chrt",
  "chvt",
  "cksum",
  "clear",
  "cmp",
  "comm",
  "cp",
  "cpio",
  "crond",
  "crontab",
  "cryptpw",
  "cut",
  "date",
  "dc",
  "dd",
  "deallocvt",
  "delgroup",
  "deluser",
  "depmod",
  "devmem",
  "df",
  "dhcprelay",
  "diff",
  "dirname",
  "dmesg",
  "dnsd",
  "dnsdomainname",
  "dos2unix",
  "dpkg",
  "du",
  "dumpkmap",
  "dumpleases",
  "echo",
  "ed",
  "egrep",
  "eject",
  "env",
  "envdir",
  "envuidgid",
  "expand",
  "expr",
  "fakeidentd",
  "false",
  "fbset",
  "fbsplash",
  "fdflush",
  "fdformat",
  "fdisk",
  "fgrep",
  "find",
  "findfs",
  "flash_lock",
  "flash_unlock",
  "fold",
  "free",
  "freeramdisk",
  "fsck",
  "fsck.minix",
  "fsync",
  "ftpd",
  "ftpget",
  "ftpput",
  "fuser",
  "getopt",
  "getty",
  "grep",
  "gunzip",
  "gzip",
  "hd",
  "hdparm",
  "head",
  "hexdump",
  "hostid",
  "hostname",
  "httpd",
  "hush",
  "hwclock",
  "id",
  "ifconfig",
  "ifdown",
  "ifenslave",
  "ifplugd",
  "ifup",
  "inetd",
  "init",
  "inotifyd",
  "insmod",
  "install",
  "ionice",
  "ip",
  "ipaddr",
  "ipcalc",
  "ipcrm",
  "ipcs",
  "iplink",
  "iproute",
  "iprule",
  "iptunnel",
  "kbd_mode",
  "kill",
  "killall",
  "killall5",
  "klogd",
  "last",
  "length",
  "less",
  "linux32",
  "linux64",
  "linuxrc",
  "ln",
  "loadfont",
  "loadkmap",
  "logger",
  "login",
  "logname",
  "logread",
  "losetup",
  "lpd",
  "lpq",
  "lpr",
  "ls",
  "lsattr",
  "lsmod",
  "lzmacat",
  "lzop",
  "lzopcat",
  "makemime",
  "man",
  "md5sum",
  "mdev",
  "mesg",
  "microcom",
  "mkdir",
  "mkdosfs",
  "mkfifo",
  "mkfs.minix",
  "mkfs.vfat",
  "mknod",
  "mkpasswd",
  "mkswap",
  "mktemp",
  "modprobe",
  "more",
  "mount",
  "mountpoint",
  "mt",
  "mv",
  "nameif",
  "nc",
  "netstat",
  "nice",
  "nmeter",
  "nohup",
  "nslookup",
  "od",
  "openvt",
  "passwd",
  "patch",
  "pgrep",
  "pidof",
  "ping",
  "ping6",
  "pipe_progress",
  "pivot_root",
  "pkill",
  "popmaildir",
  "printenv",
  "printf",
  "ps",
  "pscan",
  "pwd",
  "raidautorun",
  "rdate",
  "rdev",
  "readlink",
  "readprofile",
  "realpath",
  "reformime",
  "renice",
  "reset",
  "resize",
  "rm",
  "rmdir",
  "rmmod",
  "route",
  "rpm",
  "rpm2cpio",
  "rtcwake",
  "run-parts",
  "runlevel",
  "runsv",
  "runsvdir",
  "rx",
  "script",
  "scriptreplay",
  "sed",
  "sendmail",
  "seq",
  "setarch",
  "setconsole",
  "setfont",
  "setkeycodes",
  "setlogcons",
  "setsid",
  "setuidgid",
  "sh",
  "sha1sum",
  "sha256sum",
  "sha512sum",
  "showkey",
  "slattach",
  "sleep",
  "softlimit",
  "sort",
  "split",
  "start-stop-daemon",
  "stat",
  "strings",
  "stty",
  "su",
  "sulogin",
  "sum",
  "sv",
  "svlogd",
  "swapoff",
  "swapon",
  "switch_root",
  "sync",
  "sysctl",
  "syslogd",
  "tac",
  "tail",
  "tar",
  "taskset",
  "tcpsvd",
  "tee",
  "telnet",
  "telnetd",
  "test",
  "tftp",
  "tftpd",
  "time",
  "timeout",
  "top",
  "touch",
  "tr",
  "traceroute",
  "true",
  "tty",
  "ttysize",
  "udhcpc",
  "udhcpd",
  "udpsvd",
  "umount",
  "uname",
  "uncompress",
  "unexpand",
  "uniq",
  "unix2dos",
  "unlzma",
  "unlzop",
  "unzip",
  "uptime",
  "usleep",
  "uudecode",
  "uuencode",
  "vconfig",
  "vi",
  "vlock",
  "volname",
  "watch",
  "watchdog",
  "wc",
  "wget",
  "which",
  "who",
  "whoami",
  "xargs",
  "yes",
  "zcat",
  "zcip"
};} {public global
}

comment {bourne_builtins
List of known bourne shell built-in functions...
  $ help
List of known bourne shell conditional statements...} {not_in_source in_header
}

decl {const char *bourne_function[] = {
  "alias",
  "bg",
  "break",
  "cd",
  "chdir",
  "command",
  "continue",
  "echo",
  "eval",
  "exec",
  "exit",
  "export",
  "false",
  "fg",
  "getopts",
  "hash",
  "help",
  "history",
  "jobs",
  "kill",
  "let",
  "local",
  "printf",
  "pwd",
  "read",
  "readonly",
  "return",
  "set",
  "shift",
  "source",
  "test",
  "times",
  "trap",
  "true",
  "type",
  "ulimit",
  "umask",
  "unalias",
  "unset",
  "wait"
};} {public global
}

decl {const char *bourne_keys[] = {
  "case",
  "do",
  "done",
  "elif",
  "else",
  "esac",
  "fi",
  "for",
  "if",
  "in",
  "then",
  "until",
  "while",
};} {public global
}

comment {bourne_again_builtins
List of known bourne again shell built-in functions...
  $ compgen -b
List of known bourne again shell conditional statements...
  $ compgen -k} {not_in_source in_header
}

decl {const char *bourne_again_function[] = {
  "alias",
  "bg",
  "bind",
  "break",
  "builtin",
  "caller",
  "cd",
  "command",
  "compgen",
  "complete",
  "compopt",
  "continue",
  "declare",
  "dirs",
  "disown",
  "echo",
  "enable",
  "eval",
  "exec",
  "exit",
  "export",
  "false",
  "fc",
  "fg",
  "getopts",
  "hash",
  "help",
  "history",
  "jobs",
  "kill",
  "let",
  "local",
  "logout",
  "mapfile",
  "popd",
  "printf",
  "pushd",
  "pwd",
  "read",
  "readarray",
  "readonly",
  "return",
  "set",
  "shift",
  "shopt",
  "source",
  "suspend",
  "test",
  "times",
  "trap",
  "true",
  "type",
  "typeset",
  "ulimit",
  "umask",
  "unalias",
  "unset",
  "wait"
};} {public global
}

decl {const char *bourne_again_keys[] = {
  "case",
  "do",
  "done",
  "elif",
  "else",
  "esac",
  "fi",
  "for",
  "function",
  "if",
  "in",
  "select",
  "then",
  "time",
  "until",
  "while"
};} {public global
}

decl {struct syntax {
  bool cm; // \#comment 35
  bool es; // \\escapes 92
  bool ds; // $dolor_sign 36
  bool se; // ${shell expansion}, ds must be true
  bool bq; // `back quote command substitution` 96
  bool sq; // 'single quote' 39
  bool dq; // "double quote" 34
  int pssp; // previous scan starting position
  int cs; // $(command substitution)
  int p; // (parentheses) 40 41
};} {public global
}

decl {struct syntax VARS;} {private global
}

decl {const char *SHELL = ""; // = "\#!/bin/sh\\n";} {private global
}

decl {char filename[FL_PATH_MAX], title[FL_PATH_MAX];} {private global
}

decl {char search_string[2048];} {private global
}

decl {char replace_string[2048];} {private global
}

decl {bool color = false, auto_indent = false, indenting = false, changed = false, is_bash = false;} {private global
}

decl {Fl_Text_Buffer *buff = new Fl_Text_Buffer();} {private global
}

decl {Fl_Text_Buffer *stylebuf = new Fl_Text_Buffer();} {private global
}

decl {\#define TS 14} {private global
}

comment {Style table
http://www.fltk.org/doc-1.3/Enumerations_8H.html
http://www.fltk.org/doc-1.3/fltk-colormap.png
A - Plain
B - busybox
C - special_characters
D - bourne_function
E - command substitution
F - Single Quotes
G - Double Quotes
H - escapes
I - bourne_variables
J - comments
K - bourne_constructs} {in_source not_in_header
}

decl {Fl_Text_Display::Style_Table_Entry styletable[] = {
  { FL_BLACK, FL_COURIER, TS },
  { 82, FL_COURIER_BOLD, TS },
  { FL_DARK_MAGENTA, FL_COURIER_BOLD,TS },
  { 92, FL_COURIER_BOLD, TS },
  { FL_DARK_GREEN, FL_COURIER, TS },
  { FL_BLUE, FL_COURIER_BOLD, TS },
  { FL_DARK_CYAN, FL_COURIER,TS },
  { FL_DARK_YELLOW, FL_COURIER,TS },
  { FL_DARK_RED, FL_COURIER_BOLD, TS },
  { FL_DARK2, FL_COURIER_ITALIC, TS },
  { FL_MAGENTA, FL_COURIER_BOLD, TS }
};} {private global
}

Function {buffer_init()} {open return_type void
} {
  code {// attach buffer to editor
buff->text(SHELL);
edit->buffer(buff);
edit->insert_position(strlen(SHELL));
edit->show_insert_position();
buff->add_modify_callback(modification_cb, edit);
// associate style & buffer
edit->highlight_data(
  stylebuf,
  styletable,
  sizeof(styletable) / sizeof(styletable[0]),
  'A',
  style_unfinished_cb,
  0 // void*
);
// buff->add_modify_callback(style_update, edit);
// buff->add_modify_callback(modification_cb, edit);} {}
}

Function {chk_bash()} {return_type void
} {
  codeblock {if (buff->char_at(0) == 35 && buff->char_at(1) == 33)} {} {
    comment {boolean is_bash
check for shebang "\#!"} {in_source not_in_header
    }
    code {int firstline = buff->line_end(0);
// either a pointer to the newline character ending the line
// or a pointer to one character beyond the end of the buffer
char *shell;
shell = buff->text_range(firstline - 4, firstline);
if (strcmp(shell, "bash") == 0) is_bash = true;
else is_bash = false;
free(shell);
return;} {}
  }
  code {// default value
is_bash = false;} {}
}

Function {shell_cb(int choice)} {open return_type void
} {
  code {if (choice == 1) {
  SHELL = "\#!/bin/sh\\n";
  chk_bash();
  if (is_bash) {
    is_bash = false;
    shebang(1);
  } else shebang(0);
  return;
}
if (choice == 2) {
  SHELL = "\#!/usr/bin/env bash\\n";
  chk_bash();
  if (is_bash) shebang(0);
  else {
    is_bash = true;
    shebang(1);
  }
  return;
}
SHELL = "";
chk_bash();
if (is_bash) {
  is_bash = false;
  shebang(1);
} else shebang(0);} {}
}

Function {shebang(int restyle)} {return_type void
} {
  code {int shell_len = strlen(SHELL);
if (shell_len == 0) {
  if (restyle && color) stylebuf_init();
  return;
}
int firstline, current_pos;
char style[21];
current_pos = edit->insert_position();

if (color && !restyle) {
  memset(style, 'J', shell_len - 1);
  style[shell_len - 1] = 10; // '\\n'
  style[shell_len] = 0; // '\\0'
}

// check for shebang "\#!"
if (buff->char_at(0) == 35 && buff->char_at(1) == 33) {
  // search_forward(int startPos, const char *searchString, int *foundPos, int matchCase = 0)
  int found = buff->search_forward(0, "\\n", &firstline);
  if (found) {
    buff->replace(0, firstline + 1, SHELL);
    if (color && !restyle) stylebuf->replace(0, firstline + 1, style);
    edit->insert_position(current_pos + shell_len - firstline - 1);
  } else {
    // no newline char
    buff->text(SHELL);
    if (color) stylebuf->text(style);
    edit->insert_position(shell_len);
  }
} else {
  buff->insert(0, SHELL);
  if (color && !restyle) stylebuf->insert(0, style);
  edit->insert_position(current_pos + shell_len);
}
edit->show_insert_position();
// restyle, "is_bash" has been changed
if (restyle && color) stylebuf_init();} {}
}

Function {check_saved()} {return_type int
} {
  code {// 1:good, 0:cancel
if (!changed) return 1;
int r = fl_choice(
  "The current file has not been saved.\\nWould you like to save it now?",
  "Cancel", "Save", "Don't Save"
);
// Cancel = 0, Save = 1, Don't Save = 2
if (r == 1) {
  save_cb(); // Save the file...
  return !changed;
}
// if (r == 2) changed = false;
return r;} {}
}

Function {new_cb()} {return_type void
} {
  code {if (!check_saved()) return;
if (SHELL) {
  buff->text(SHELL);
  // coloring
  if (color) stylebuf_init();
}
/*
if (color) {
  color_cb(); // called twice
  buff->text(SHELL);
  color_cb(); // to refresh
} else {
  buff->text(SHELL);
}
*/
edit->insert_position(strlen(SHELL));
edit->show_insert_position();
strcpy(filename, "");
strcpy(title, "");
win->label(title);
changed = false;} {}
}

Function {save_file(const char *newfile)} {return_type void
} {
  code {// Save file
// auto append trailing "\\n"
int buff_end;
buff_end = buff->length();
char last_char;
last_char = buff->char_at(buff_end - 1);
if (last_char != 10) {
  buff->append("\\n");
  edit->insert_position(buff_end + 1);
  edit->show_insert_position();
}
// fl_alert("Saving to file %s", newfile);
if (buff->savefile(newfile)) {
  fl_alert("Error writing to file \\'%s\\':\\n%s.", newfile, strerror(errno));
} else {
  strcpy(filename, newfile);
  strcpy(title, newfile);
  win->label(title);
  changed = false;
  \#ifdef __linux__
    char chmod[FL_PATH_MAX + 9];
    sprintf(chmod, "chmod +x %s", newfile);
    system(chmod);
  \#endif
}} {}
}

Function {saveas_cb()} {return_type void
} {
  code {char *sfa;
sfa = fl_file_chooser("Save File As ?", "*", filename);
if(sfa != NULL) save_file(sfa);} {}
}

Function {save_cb()} {return_type void
} {
  code {if (filename[0] == 0) {
  // No filename
  saveas_cb();
} else {
  save_file(filename);
}} {}
}

Function {open_cb()} {return_type void
} {
  code {if (!check_saved()) return;
char *newfile = fl_file_chooser("Open File ?", "*", filename);
if (newfile != NULL) load_file(newfile);} {}
}

Function {load_file(char *newfile)} {return_type void
} {
  code {bool color_resume = color;
// disable color before loading
if (color_resume) {
  color_cb();
}
int lf;
lf = buff->loadfile(newfile);
if (lf) {
  fl_alert("Error while loading file \\'%s\\':\\n%s.", newfile, strerror(errno));
} else {
  strcpy(filename, newfile);
  strcpy(title, newfile);
  win->label(title);
  changed = false;
}} {}
  code {// is_bash
// check for shebang "\#!"
if (buff->char_at(0) == 35 && buff->char_at(1) == 33) {
  int firstline = buff->line_end(0);
  // either a pointer to the newline character ending the line
  // or a pointer to one character beyond the end of the buffer
  char *shell;
  shell = buff->text_range(firstline - 4, firstline);
  if (strcmp(shell, "bash") == 0) is_bash = true;
  else is_bash = false;
  free(shell);
}
if (color_resume) color_cb();} {}
}

Function {style_unfinished_cb(int, void*)} {return_type void
} {
  comment {call back for highlight data
if style 'A' is found,
this call back will be called.
void *cbArg will be passed as arguement
fl_alert("style_unfinished_cb");} {in_source not_in_header
  }
}

Function {busybox(char *textbuff, char *scanned_text)} {return_type int
} {
  code {return compare_keywords(
  textbuff,
  applets,
  sizeof(applets)/sizeof(*applets),
  scanned_text,
  66
);} {}
}

Function {bourne_builtins(char *textbuff, char *scanned_text)} {return_type int
} {
  comment {compare_keywords(
  address_to_buff,
  array,
  sizeof_array,
  address_to_result,
  color_style(A~K)
)} {in_source not_in_header
  }
  codeblock {if (is_bash)} {} {
    code {int bourne_again;
bourne_again = compare_keywords(
  textbuff,
  bourne_again_function,
  sizeof(bourne_again_function)/sizeof(*bourne_again_function),
  scanned_text,
  68
);
if (bourne_again == 0) {
  bourne_again = compare_keywords(
    textbuff,
    bourne_again_keys,
    sizeof(bourne_again_keys)/sizeof(*bourne_again_keys),
    scanned_text,
    75
  );
}
return bourne_again;} {}
  }
  code {int bourne;
bourne = compare_keywords(
  textbuff,
  bourne_function,
  sizeof(bourne_function)/sizeof(*bourne_function),
  scanned_text,
  68
);
if (bourne == 0) {
  bourne = compare_keywords(
    textbuff,
    bourne_keys,
    sizeof(bourne_keys)/sizeof(*bourne_keys),
    scanned_text,
    75
  );
}
return bourne;} {}
}

Function {is_special(char ascii)} {return_type int
} {
  code {// 33~47, 58~64, 91~96, 123~126
if (ascii == 95) {
  // 95 _ usually treated as normal string
  // only exception $_
  // already handled
  return 0;
}
if (ascii > 32 && ascii < 48) {
  return 1;
}
if (ascii > 57 && ascii < 65) {
  return 2;
}
if (ascii > 90 && ascii < 97) {
  return 3;
}
if (ascii > 122 && ascii < 127) {
  return 4;
}
return 0;} {}
}

Function {disable_color()} {return_type void
} {
  code {// buff->remove_modify_callback(modification_cb, edit);
// hopefully disable the style thing
stylebuf->text("");
// edit->highlight_data(NULL, NULL, NULL, NULL, NULL);} {}
}

Function {auto_indent_switch()} {return_type void
} {
  code {auto_indent = !auto_indent;
if (auto_indent) {
  indent_switch->label("No  Indent");
} else {
  indent_switch->label("AutoIndent");
}} {}
}

Function {auto_indent_cb(int lsp, int pos, char *line)} {return_type void
} {
  comment {lsp: line start pos
pos: insert position
line: entire line
} {in_source not_in_header
  }
  code {size_t current_pos = pos + 1; // '\\n'
// '\\n'indent_space'\\0'
char *indention = (char *)malloc(current_pos - lsp); // pos - lsp + 1

size_t ai = 0;
for (;ai < (current_pos - lsp);ai++) {
  // tab || space
  if (line[ai] == 9 || line[ai] == 32) indention[ai] = line[ai];
  else break;
}
if (ai == 0) {
  /*
  if (color) {
    indention[0] = 10; // '\\n'
    indention[0] = 0; // '\\0'
    stylebuf->replace(current_pos, current_pos, indention);
  }
  */
  free(indention);
  free(line);
  edit->insert_position(current_pos - 1);
  return;
}
indention[ai] = 0; // '\\0'
buff->insert(current_pos, indention); // will call modification_cb
// stylebuf is one char slower than buff
current_pos += strlen(indention);
if (color) {
  // modification_cb already handle the inserted '\\n', using "replace"
  stylebuf->replace(pos + 1, current_pos, indention);
}
free(indention);
free(line);
edit->insert_position(current_pos - 1);} {}
}

Function {stylebuf_init()} {return_type void
} {
  code {// VARS init
VARS.pssp = 0;
VARS.cm = false;
VARS.es = false;
VARS.ds = false;
VARS.se = false;
VARS.bq = false;
VARS.sq = false;
VARS.dq = false;
VARS.pssp = 0;
VARS.cs = 0;
VARS.p = 0;} {}
  code {// buff_copy
int bufflen;
char *buff_copy;
buff_copy = buff->text(); // full copy
if (buff_copy) {
  bufflen = strlen(buff_copy); // end_pos + 1
} else {
  fl_alert("*** Error, malloc failed ***\\nDisabling the coloring!");
  color_cb();
  return;
}
scan_forward(buff_copy, bufflen, 0);
free(buff_copy);
return;} {}
}

Function {color_cb()} {return_type void
} {
  code {color = !color;
if (color) {
  stylebuf_init();
  color_switch->label("NoColor");
} else {
  disable_color();
  color_switch->label("Colorful");
}
edit->redisplay_range(0, buff->length());} {}
}

Function {compare_keywords(char *text, const char *keys[], size_t elements, char *result, char ascii)} {return_type int
} {
  code {const char *needle;
size_t nl; // needle length
size_t k = 0;
size_t mp; // matching point
for (; k < elements; k++) {
  needle = keys[k];
  nl = strlen(needle);
  // matching first char
  if (*text == *needle) {
    // check posterior
    switch (text[nl]) {
      case 0: // end of string
      case 9: // tab
      case 10: // newline
      case 32: // space
      case 38: // &
      case 41: // )
      case 59: // ;
      case 60: // <
      case 62: // >
      case 96: // `
      case 124: // |
        break;
      default:
        // next keyword
        continue;
    }
    for (mp = 1; mp < nl; mp++) {
      // matching
      if (text[mp] != needle[mp]) {
        // next element
        break;
      }
    }
    if (mp == nl) {
      // matched
      break;
    }
  } else {
    continue;
  }
}
if (k != elements) {
  while (*needle++) {
    *result = ascii;
    result++;
  }
  return nl - 1;
}
return 0;} {}
}

Function {setvars(char *buff_copy, int pos)} {return_type void
} {
  code {// VARS init
VARS.cm = false;
VARS.es = false;
VARS.ds = false;
VARS.se = false;
VARS.bq = false;
VARS.sq = false;
VARS.dq = false;
VARS.cs = 0;
VARS.p = 0;} {}
  code {int setvar = 0;

// [[fallthrough]]; --> suppress the fallthrough warning

for (;setvar < pos; setvar++) {
  switch(buff_copy[setvar]) {
    case 10: // newline
      if (VARS.cm) VARS.cm = !VARS.cm;
      [[fallthrough]];
    case 9: // tab
      [[fallthrough]];
    case 32: // space
      if (VARS.ds) VARS.ds = !VARS.ds;
      continue;
    case 34: // "double quote"
      if (VARS.cm) break;
      if (!VARS.sq) {
        VARS.dq = !VARS.dq;
        if (VARS.ds) VARS.ds = !VARS.ds;
        continue;
      }
      break;
    case 35: // \#comment
      if (!VARS.ds && !VARS.sq && !VARS.dq && !VARS.se) {
        VARS.cm = true;
      }
      break;
    case 36: // $dolor_sign
      if (VARS.cm || VARS.sq) break;
      VARS.ds = true;
      switch(buff_copy[setvar+1]) {
        case 33: // built-in variable $!
        case 35: // built-in variable $\#
        case 36: // built-in variable $$
        case 42: // built-in variable $*
        case 45: // built-in variable $-
        case 63: // built-in variable $?
        case 64: // built-in variable $@
        case 95: // built-in variable $_
          setvar++;
          VARS.ds = false;
          continue;
        case 40: // $(...
          VARS.cs++;
          VARS.p++;
          setvar++;
          VARS.ds = false;
          continue;
        case 123: // shell expansion ${
          // cb++;
          VARS.se = true; // a bit redundant
          setvar++;
          VARS.ds = true;
          continue;
        case 0: // '\\0'
        case 9: // tab
        case 10: // newline
        case 32: // space
        case 47: // regular expression /$/
          // trailing dolor_sign$
          VARS.ds = false;
          // resume default
          continue;
      }
      if (is_special(buff_copy[setvar+1])) {
        // invalid variable $, or such
        // resume default
        VARS.ds = false;
      }
      break;
    case 39: // 'single quote'
      if (VARS.cm) break;
      // single quote is always
      // treated literally in double quote
      if (!VARS.dq) {
        VARS.sq = !VARS.sq;
        continue;
      }
      break;
    case 40: // (
      if (VARS.cm || VARS.sq || VARS.dq) break;
      VARS.p++;
      break;
    case 41: // )
      if (VARS.cm || VARS.sq) break;
      if (VARS.ds) VARS.ds = !VARS.ds;
      if (VARS.dq && VARS.cs == 0) break;
      VARS.p--;
      break;
    case 92: // \\escapes
      if (!VARS.cm && !VARS.sq) VARS.es = true;
      break; // other escape
    case 96: // `back quote`
      if (VARS.cm || VARS.sq) break;
      VARS.ds = false;
      VARS.bq = !VARS.bq;
      continue;
    case 125: // }
      if (VARS.cm || VARS.sq) break;
      if (VARS.ds || VARS.se) {
        // end of variable
        VARS.ds = false;
        VARS.se = false;
        continue;
      }
      break;
  }
  if (VARS.se) continue;
  if (VARS.cm) {
    if (buff_copy[setvar] == 10) VARS.cm = false;
    continue;
  }
  if (VARS.sq) {
    // 'single quote' ignore escapes
    if (buff_copy[setvar] == 39) VARS.sq = !VARS.sq;
    continue;
  }
  if (VARS.ds) {
    if (is_special(buff_copy[setvar+1]) || buff_copy[setvar+1] == 0) {
      // end of variable
      VARS.ds = false;
      continue;
    }
  }
  if (VARS.es) {
    // this char = backslash (92)
    if (VARS.dq && buff_copy[setvar+1] == 39) {
      // echo "\\'" --> \\'
      VARS.es = false;
      continue;
    }
    if (buff_copy[setvar+1] == 120) {
      // hex \\xFF 48~57, 65~70, 97~102
      bool hex = ((
        (buff_copy[setvar+2] > 47 && buff_copy[setvar+2] < 58) ||
        (buff_copy[setvar+2] > 64 && buff_copy[setvar+2] < 71) ||
        (buff_copy[setvar+2] > 96 && buff_copy[setvar+2] < 103)
      ) && (
        (buff_copy[setvar+3] > 47 && buff_copy[setvar+3] < 58) ||
        (buff_copy[setvar+3] > 64 && buff_copy[setvar+3] < 71) ||
        (buff_copy[setvar+3] > 96 && buff_copy[setvar+3] < 103)
      ));
      if (hex) setvar+=2;
    }
    setvar++;
    VARS.es = false;
    continue;
  }
  if (VARS.cs > 0) {
    if (buff_copy[setvar] == 41) {
      // )
      VARS.cs--;
      if (VARS.p > VARS.cs) VARS.cs++;
    }
    // continue;
  }
}} {}
}

Function {scan_forward(char *buff_copy, int bufflen, int pos)} {return_type void
} {
  code {char *scan;
scan = (char*)malloc(bufflen - pos + 1);
if (scan) {
  memset(scan, 65, bufflen - pos); // 'A'
  scan[bufflen - pos] = 0; // '\\0'
} else {
  fl_alert("*** Error, malloc failed ***\\nDisabling the coloring!");
  color_cb();
  return;
}} {}
  code {struct syntax UPDATE;
// duplicate the struct to preserve VARS values
UPDATE = VARS;} {}
  code {int j = 0;
int m = 0;
bool key = true;

// [[fallthrough]]; --> suppress the fallthrough warning

for (;j < bufflen - pos; j++) \{
  switch(buff_copy[j+pos]) \{
    case 10: // newline
      if (UPDATE.cm) UPDATE.cm = !UPDATE.cm;
      [[fallthrough]];
    case 9: // tab
      [[fallthrough]];
    case 32: // space
      key = true;
      if (UPDATE.ds) UPDATE.ds = !UPDATE.ds;
      scan[j] = buff_copy[j+pos];
      continue;
    case 34: // "double quote"
      if (UPDATE.cm) break;
      if (!UPDATE.sq) \{
        UPDATE.dq = !UPDATE.dq;
        scan[j] = 'G';
        if (UPDATE.ds) UPDATE.ds = !UPDATE.ds;
        continue;
      \}
      break;
    case 35: // \#comment
      key = false;
      if (!UPDATE.ds && !UPDATE.sq && !UPDATE.dq && !UPDATE.se) \{
        UPDATE.cm = true;
        scan[j] = 'J';
      \}
      break;
    case 36: // $dolor_sign
      key = false;
      if (UPDATE.cm || UPDATE.sq) break;
      UPDATE.ds = true;
      switch(buff_copy[j+pos+1]) \{
        case 33: // built-in variable $!
        case 35: // built-in variable $\#
        case 36: // built-in variable $$
        case 42: // built-in variable $*
        case 45: // built-in variable $-
        case 63: // built-in variable $?
        case 64: // built-in variable $@
        case 95: // built-in variable $_
          scan[j] = 'I';
          j++;
          scan[j] = 'I';
          UPDATE.ds = false;
          continue;
        case 40: // $(...
          UPDATE.cs++;
          UPDATE.p++;
          scan[j] = 'E';
          j++;
          scan[j] = 'E';
          key = true;
          UPDATE.ds = false;
          continue;
        case 123: // shell expansion $\{
          // cb++;
          UPDATE.se = true; // a bit redundant
          scan[j] = 'I';
          j++;
          scan[j] = 'I';
          UPDATE.ds = true;
          continue;
        case 0: // '\\0'
        case 9: // tab
        case 10: // newline
        case 32: // space
        case 47: // regular expression /$/
          // trailing dolor_sign$
          UPDATE.ds = false;
          // resume default
          scan[j] = 'A';
          continue;
      \}
      scan[j] = 'I';
      if (is_special(buff_copy[j+pos+1])) \{
        // invalid variable $, or such
        // resume default
        UPDATE.ds = false;
        scan[j] = 'A';
      \}
      break;
    case 39: // 'single quote'
      key = false;
      if (UPDATE.cm) break;
      // single quote is always
      // treated literally in double quote
      if (!UPDATE.dq) \{
        UPDATE.sq = !UPDATE.sq;
        scan[j] = 'F';
        continue;
      \}
      break;
    case 40: // (
      key = true;
      if (UPDATE.cm || UPDATE.sq || UPDATE.dq) break;
      UPDATE.p++;
      scan[j] = 'C';
      break;
    case 41: // )
      key = false;
      if (UPDATE.cm || UPDATE.sq) break;
      if (UPDATE.ds) UPDATE.ds = !UPDATE.ds;
      if (UPDATE.dq) \{
        if (UPDATE.cs == 0)
        break;
      \}
      UPDATE.p--;
      scan[j] = 'C';
      break;
    case 92: // \\escapes
      key = false;
      if (!UPDATE.cm && !UPDATE.sq) UPDATE.es = true;
      break; // other escape
    case 96: // `back quote`
      key = true;
      if (UPDATE.cm || UPDATE.sq) break;
      scan[j] = 'E';
      UPDATE.ds = false;
      UPDATE.bq = !UPDATE.bq;
      continue;
    case 123: // \{
      scan[j] = 'C';
      break;
    case 125: // \}
      if (UPDATE.cm || UPDATE.sq) break;
      if (UPDATE.ds || UPDATE.se) \{
        // end of variable
        UPDATE.ds = false;
        UPDATE.se = false;
        scan[j] = 'I';
        continue;
      \}
      scan[j] = 'C';
      break;
    case 38: // &
    case 59: // ;
    case 60: // <
    case 62: // >
    case 124: // >
      // 38, 59, 60, 62, 124 fall through to default
      key = true;
      [[fallthrough]];
    default:
      if (UPDATE.cm || UPDATE.es || UPDATE.sq) break;
      // scan[j] = 'A'; --> overwrite the keywords
      if (is_special(buff_copy[j+pos])) scan[j] = 'C';
  \}
  if (UPDATE.se) \{
    scan[j] = 'I';
    continue;
  \}
  if (UPDATE.cm) \{
    switch (buff_copy[j+pos]) \{
      case 10: // newline
        UPDATE.cm = false;
        [[fallthrough]];
      case 9: // tab
      case 32: // space
        scan[j] = buff_copy[j+pos];
        break;
      default:
        scan[j] = 'J';
    \}
    continue;
  \}
  if (UPDATE.sq) \{
    // 'single quote' ignore escapes
    scan[j] = 'F';
    if (buff_copy[j+pos] == 39) UPDATE.sq = !UPDATE.sq;
    continue;
  \}
  if (UPDATE.dq) scan[j] = 'G';
  if (UPDATE.ds) \{
    scan[j] = 'I';
    if (is_special(buff_copy[j+pos+1]) || buff_copy[j+pos+1] == 0) \{
      // end of variable
      UPDATE.ds = false;
      continue;
    \}
  \}
  if (UPDATE.es) \{
    // this char = backslash (92)
    if (buff_copy[j+pos+1]) \{
      // char not null
      scan[j] = 'H';
      scan[j+1] = 'H';
    \}
    if (UPDATE.dq && buff_copy[j+pos+1] == 39) \{
      // echo "\\'" --> \\'
      UPDATE.es = false;
      continue;
    \}
    if (buff_copy[j+pos+1] == 120) \{
      // hex \\xFF 48~57, 65~70, 97~102
      bool hex = ((
        (buff_copy[j+pos+2] > 47 && buff_copy[j+pos+2] < 58) ||
        (buff_copy[j+pos+2] > 64 && buff_copy[j+pos+2] < 71) ||
        (buff_copy[j+pos+2] > 96 && buff_copy[j+pos+2] < 103)
      ) && (
        (buff_copy[j+pos+3] > 47 && buff_copy[j+pos+3] < 58) ||
        (buff_copy[j+pos+3] > 64 && buff_copy[j+pos+3] < 71) ||
        (buff_copy[j+pos+3] > 96 && buff_copy[j+pos+3] < 103)
      ));
      if (hex) \{
        scan[j+2] = 'H';
        scan[j+3] = 'H';
        j+=2;
      \}
    \}
    j++;
    UPDATE.es = false;
    continue;
  \}
  if (UPDATE.cs > 0) \{
    if (scan[j] == 'A') scan[j] = 'E';
    if (buff_copy[j+pos] == 41) \{
      // )
      scan[j] = 'E';
      UPDATE.cs--;
      if (UPDATE.p > UPDATE.cs) UPDATE.cs++;
    \}
    // continue;
  \}
  if (UPDATE.bq) \{
    if (scan[j] == 'A') scan[j] = 'E';
    // continue;
  \}
  if (key) \{
    // scan for keywords
    key = false;
    if (UPDATE.dq) \{
      if (UPDATE.cs == 0 && !UPDATE.bq)
      continue;
    \}
    // when keywords are overlapped, the "bourne_builtins" one is used
    m = bourne_builtins(&buff_copy[j+pos], &scan[j]);
    if (m == 0) m = busybox(&buff_copy[j+pos], &scan[j]);
    j += m;
  \}
\}} {}
  code {stylebuf->replace(pos, stylebuf->length(), scan);
/*
replace example:
{'s', 't', 'r', 'i', 'n', 'g'}
replace(1, 3, "ABC")
{'s', 'A', 'B', 'C', 'i', 'n', 'g'}
*/
edit->redisplay_range(pos, buff->length());
free(scan);
return;} {}
}

Function {modification_cb(int pos, int nInserted, int nDeleted, int nRestyled, const char *deletedText, void *cbArg)} {return_type void
} {
  codeblock {if (!changed)} {} {
    codeblock {if (nInserted != 0 || nDeleted != 0)} {} {
      code {// adjust title
changed = true;
strcat(title, "*");
win->label(title);} {}
    }
  }
  codeblock {if (nInserted > 0 && nDeleted > 0)} {} {
    code {// This only happens when a user undo changes
// do nothing...
return;} {}
  }
  codeblock {if (auto_indent && nInserted == 1 && buff->char_at(pos) == 10)} {} {
    code {indenting = true;
auto_indent_cb(
  buff->line_start(pos),
  pos, // insert position
  buff->line_text(pos)
);
return;} {}
  }
  code {// int scan_pos
int scan_pos;
// scan from the start of the line to check for key words
scan_pos = buff->line_start(pos);} {}
  code {// buff_copy
int bufflen;
char *buff_copy;
buff_copy = buff->text(); // full copy
if (buff_copy) {
  bufflen = strlen(buff_copy); // end_pos + 1
} else {
  fl_alert("*** Error, malloc failed ***\\nDisabling the coloring!");
  color_cb();
  return;
}} {}
  codeblock {if (nInserted == 0 && nDeleted == 0)} {} {
    codeblock {if (color)} {} {
      code {setvars(buff_copy, scan_pos);} {}
    }
    code {// selection change
stylebuf->unselect();
free(buff_copy);
return;} {}
  }
  codeblock {if (color)} {open
  } {
    codeblock {if (indenting)} {} {
      code {indenting = false;
scan_pos = buff->line_start(scan_pos - 2);} {}
    }
    codeblock {if (VARS.pssp != scan_pos || indenting)} {} {
      code {setvars(buff_copy, scan_pos);} {}
    }
    code {scan_forward(buff_copy, bufflen, scan_pos);
// fl_alert("%d\\n", scan_pos);
free(buff_copy);
VARS.pssp = scan_pos;} {}
    codeblock {if (buff->length() != stylebuf->length())} {open
    } {
      code {// catch exception
fl_alert(
  "!!!Exception occur!!!\\nbuff->length = %d\\nstylebuf->length = %d", // \\nForcing reload...",
  buff->length(),
  stylebuf->length()
);
/*
color_cb();
color_cb();
*/} {}
      code {// Debug
fl_alert("pos:%d\\nnInserted:%d\\nnDeleted:%d\\nnRestyled:%d\\ndeletedText:\\n%s",
pos, nInserted, nDeleted, nRestyled, deletedText);
fl_alert("current buffer: '%c'\\ncurrent style: '%c'",
buff->char_at(pos), stylebuf->char_at(pos));
fl_alert("current buffer: '%d'\\ncurrent style: '%d'",
buff->char_at(pos), stylebuf->char_at(pos));} {}
    }
  }
}

Function {close_cb(Fl_Widget*, void* v)} {return_type void
} {
  code {if (check_saved()) exit(0);} {}
}

Function {arg_parser(int argc, char **argv, int &i)} {open return_type int
} {
  code {if(strcmp(argv[i], "-shell") == 0) {
  SHELL = "\#!/bin/sh\\n";
  i++;
  return 1;
}
if(strcmp(argv[i], "-bash") == 0) {
  SHELL = "\#!/usr/bin/env bash\\n";
  i++;
  return 1;
}
if(strcmp(argv[i], "-other") == 0) {
  SHELL = 0;
  i++;
  return 1;
}
if(strcmp(argv[i], "-h") == 0) {
  printf(
    "%s [-options] [file]\\n"
    "Set default shebang to\\n"
    "-shell\\t\#!/bin/sh\\n"
    "-bash\\t\#!/usr/bin/env bash\\n"
    "-other\\tother unknown shebang\\n"
    "The later option will replace any previous one(s)\\n"
    "Any arguements after the \\"file\\" will be ignored\\n"
    , basename(argv[0])
  );
  exit(0);
}
return 0;} {selected
  }
  comment {http://www.fltk.org/articles.php?L744} {in_source not_in_header
  }
}

Function {find_dialog()} {return_type void
} {
  code {const char *SS = fl_input("Search String:", search_string);
// Search string is blank
if (SS == NULL || *SS == 0) return;
int sf_pos;
int sf_r = buff->search_forward(
  edit->insert_position(),
  SS,
  &sf_pos,
  0
);
if (sf_r) {
  buff->select(sf_pos, sf_pos + strlen(SS));
  edit->insert_position(sf_pos + 1);
  edit->show_insert_position();
} else {
  fl_alert("No occurrences of \\'%s\\' found!", SS);
}
strcpy(search_string, SS);} {}
}

Function {find_again_dialog()} {return_type void
} {
  code {if (*search_string == 0) {
  // Search string is blank
  find_dialog();
  return;
}
int sf_pos;
int sf_r = buff->search_forward(
  edit->insert_position(),
  search_string,
  &sf_pos,
  0
);
if (sf_r) {
  buff->select(sf_pos, sf_pos + strlen(search_string));
  edit->insert_position(sf_pos + 1);
  edit->show_insert_position();
} else {
  fl_alert("No occurrences of \\'%s\\' found!", search_string);
}} {}
}

Function {replace_dialog()} {} {
  Fl_Window replace_dialog_window {
    label Replace
    xywh {484 562 320 155} type Double hide
  } {
    Fl_Input text_in_find {
      label {Find:}
      xywh {72 20 230 30} box PLASTIC_DOWN_BOX
    }
    Fl_Input text_in_replace {
      label {Replace:}
      xywh {72 60 230 30} box PLASTIC_DOWN_BOX
    }
    Fl_Button replace_all_btn {
      label {Replace All}
      callback {replace_all_cb();}
      xywh {15 110 85 30} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX
    }
    Fl_Return_Button replace_next_btn {
      label {Replace Next}
      callback {replace_next_cb();}
      xywh {105 110 130 30} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX
    }
    Fl_Button RD_cancel_btn {
      label Cancel
      callback {close_dialog(replace_dialog_window, 0);}
      xywh {240 110 64 30} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX
    }
  }
  code {/*
replace_dialog_window->show();
const char *find = text_in_find->value();
const char *replace = text_in_replace->value();
fl_alert(find);
fl_alert(replace);
*/} {}
  code {/*
delete text_in_find;
delete text_in_replace;
delete replace_all_btn;
delete RD_cancel_btn;
delete replace_next_btn;
delete replace_dialog_window;
*/} {}
  code {text_in_find->value(search_string);
text_in_replace->value(replace_string);
replace_dialog_window->callback((Fl_Callback *)close_dialog, win);
replace_dialog_window->show();} {}
}

Function {replace_next_cb()} {return_type void
} {
  code {const char *TIF = text_in_find->value();
const char *TIR = text_in_replace->value();
// text in find is blank
if (TIF == NULL || *TIF == 0) return;
strcpy(search_string, TIF);
strcpy(replace_string, TIR);
int rpl_pos;
int rpl_r = buff->search_forward(
  edit->insert_position(),
  TIF,
  &rpl_pos,
  1
);
if (rpl_r) {
  buff->remove(rpl_pos, rpl_pos + strlen(TIF));
  buff->insert(rpl_pos, TIR);
  buff->select(rpl_pos, rpl_pos + strlen(TIR));
  edit->insert_position(rpl_pos + 1);
  edit->show_insert_position();
} else {
  fl_alert("No occurrences of \\'%s\\' found!", TIF);
}
close_dialog(replace_dialog_window, 0);} {}
}

Function {replace_again_cb()} {return_type void
} {
  code {// text in buffer is blank
if (*search_string == 0) {
  replace_dialog();
  return;
}
int rpl_pos;
int rpl_r = buff->search_forward(
  edit->insert_position(),
  search_string,
  &rpl_pos,
  1
);
if (rpl_r) {
  buff->remove(rpl_pos, rpl_pos + strlen(search_string));
  buff->insert(rpl_pos, replace_string);
  buff->select(rpl_pos, rpl_pos + strlen(replace_string));
  edit->insert_position(rpl_pos + 1);
  edit->show_insert_position();
} else {
  fl_alert("No occurrences of \\'%s\\' found!", search_string);
}} {}
}

Function {replace_all_cb()} {return_type void
} {
  code {const char *TIF = text_in_find->value();
const char *TIR = text_in_replace->value();
// text in find is blank
if (TIF == NULL || *TIF == 0) return;

strcpy(search_string, TIF);
strcpy(replace_string, TIR);
int current_pos = edit->insert_position();
edit->insert_position(0);

int counts = 0;
int found = 1;
int srh_pos = 0;
int rpl_pos = 0;
bool resume = false;

// disable coloring to speed up looping
if (color) {
  color_cb();
  resume = true;
}

while (found) {
  found = buff->search_forward(
    srh_pos,
    TIF,
    &rpl_pos,
    1
  );
  if (found) {
    buff->remove(rpl_pos, rpl_pos + strlen(TIF));
    buff->insert(rpl_pos, TIR);
    counts++;
  }
  if (rpl_pos > srh_pos) srh_pos = rpl_pos + 1;
}

if (resume) color_cb();

if (counts) fl_message("Replaced %d occurrences.", counts);
else fl_alert("No occurrences of \\'%s\\' found!", TIF);

close_dialog(replace_dialog_window, 0);
edit->insert_position(current_pos);} {}
}

Function {close_dialog(Fl_Widget*, void* v)} {return_type void
} {
  code {// fl_alert("Before deleting");
delete text_in_find;
delete text_in_replace;
delete replace_all_btn;
delete RD_cancel_btn;
delete replace_next_btn;
delete replace_dialog_window;
// fl_alert("After deleting");} {}
}

Function {} {open
} {
  Fl_Window win {
    xywh {640 206 425 320} type Double box PLASTIC_UP_BOX resizable visible
  } {
    Fl_Text_Editor edit {
      xywh {1 29 424 288} box PLASTIC_DOWN_FRAME textfont 4 textsize 20 resizable
    }
    Fl_Menu_Bar menu_bar {open
      xywh {0 0 425 30} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX
    } {
      Submenu file_menu {
        label File
        xywh {0 0 67 24}
      } {
        MenuItem new_bt {
          label {&New File}
          callback {new_cb();}
          xywh {0 0 34 24} shortcut 0x4006e
        }
        MenuItem open {
          label {&Open}
          callback {open_cb();}
          xywh {0 0 100 20} shortcut 0x4006f
        }
        MenuItem save {
          label {&Save}
          callback {save_cb();}
          xywh {0 0 100 20} shortcut 0x40073
        }
        MenuItem saveas {
          label {Save &As}
          callback {saveas_cb();}
          xywh {0 0 34 24} shortcut 0x50073
        }
      }
      Submenu shell_menu {
        label Shell open
        xywh {0 0 67 24}
      } {
        MenuItem sh {
          label {POSIX sh}
          callback {shell_cb(1);}
          xywh {0 0 34 24} shortcut 0x80073
        }
        MenuItem bash {
          label {ENV bash}
          callback {shell_cb(2);}
          xywh {0 0 34 24} shortcut 0x80062
        }
        MenuItem other {
          label Other
          callback {shell_cb(0);}
          xywh {0 0 30 20}
        }
      }
      Submenu search_menu {
        label Search open
        xywh {0 0 63 20}
      } {
        MenuItem find_btn {
          label {&Find}
          callback {find_dialog();}
          xywh {0 0 30 20} shortcut 0x40066
        }
        MenuItem find_again_btn {
          label {Find A&gain}
          callback {find_again_dialog();}
          xywh {0 0 30 20} shortcut 0x40067
        }
        MenuItem replace_btn {
          label {&Replace}
          callback {replace_dialog();}
          xywh {0 0 30 20} shortcut 0x40072
        }
        MenuItem replace_again_btn {
          label {Replace &Again}
          callback {replace_again_cb();}
          xywh {0 0 30 20} shortcut 0x40074
        }
      }
      MenuItem color_switch {
        label Colorful
        callback {color_cb();}
        xywh {0 0 67 24}
      }
      MenuItem indent_switch {
        label {Auto Indent}
        callback {auto_indent_switch();}
        xywh {0 0 30 20}
      }
    }
  }
  code {// arguements
int arg_file;
Fl::args(argc, argv, arg_file, &arg_parser);} {}
  code {// editor init
win->label(title);
buffer_init();} {}
  codeblock {if (arg_file < argc)} {open
  } {
    code {load_file(argv[arg_file]);} {}
  }
  code {memset(search_string, 0, 2048);
memset(replace_string, 0, 2048);} {}
  code {win->callback((Fl_Callback *)close_cb, win);} {}
}
