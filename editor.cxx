// author polikuo 2018
// generated by Fast Light User Interface Designer (fluid) version 1.0304

#include "editor.h"
char const *SHELL = "#!/bin/sh\n"; 
char filename[FL_PATH_MAX], title[FL_PATH_MAX]; 
Fl_Text_Buffer *buff = new Fl_Text_Buffer(); 
bool color = false, auto_indent = false, indenting = false, changed = false; 
Fl_Text_Buffer *stylebuf = new Fl_Text_Buffer(); 
#define TS 14
// Style table
// http://www.fltk.org/doc-1.3/Enumerations_8H.html
// http://www.fltk.org/doc-1.3/fltk-colormap.png
// A - Plain
// B - busybox
// C - special_characters
// D - bourne_function
// E - command substitution
// F - Single Quotes
// G - Double Quotes
// H - escapes
// I - bourne_variables
// J - comments
// K - bourne_constructs
Fl_Text_Display::Style_Table_Entry styletable[] = {
  { FL_BLACK, FL_COURIER, TS },
  { 82, FL_COURIER_BOLD, TS },
  { FL_DARK_MAGENTA, FL_COURIER_BOLD,TS },
  { 92, FL_COURIER_BOLD, TS },
  { FL_DARK_GREEN, FL_COURIER, TS },
  { FL_BLUE, FL_COURIER_BOLD, TS },
  { FL_DARK_CYAN, FL_COURIER,TS },
  { FL_DARK_YELLOW, FL_COURIER,TS },
  { FL_DARK_RED, FL_COURIER_BOLD, TS },
  { FL_DARK2, FL_COURIER_ITALIC, TS },
  { FL_MAGENTA, FL_COURIER_BOLD, TS }
}; 

void buffer_init() {
  // attach buffer to  editor
  buff->text(SHELL);
  edit->buffer(buff);
  edit->insert_position(10);
  edit->show_insert_position();
  buff->add_modify_callback(modification_cb, edit);
}

void shebang() {
  if (strlen(SHELL) == 0) return;
  int firstline, current_pos;
  current_pos = edit->insert_position();
  // search_forward(int startPos, const char *searchString, int *foundPos, int matchCase = 0)
  int found = buff->search_forward(0, "\n", &firstline);
  if (found) {
    buff->select(0, firstline+1);
    buff->remove_selection();
    buff->insert(0, SHELL);
    edit->insert_position(current_pos + strlen(SHELL) - firstline - 1);
    edit->show_insert_position();
  } else {
    // no newline char
    buff->text(SHELL);
    edit->insert_position(strlen(SHELL));
    edit->show_insert_position();
  }
}

int check_saved(void) {
  // 1:good, 0:cancel
  if (!changed) return 1;
  int r = fl_choice(
    "The current file has not been saved.\nWould you like to save it now?",
    "Cancel", "Save", "Don't Save"
  );
  // Cancel = 0, Save = 1, Don't Save = 2
  if (r == 1) {
    save_cb(); // Save the file...
    return !changed;
  }
  if (r == 2) changed = false;
  return r;
}

void new_cb() {
  if (!check_saved()) return;
  // coloring
  if (color) {
    color_cb(); // called twice
    buff->text(SHELL);
    color_cb(); // to refresh
  } else {
    buff->text(SHELL);
  }
  edit->insert_position(strlen(SHELL));
  edit->show_insert_position();
  strcpy(filename, "");
  strcpy(title, "");
  win->label(title);
  changed = false;
}

void save_file(const char *newfile) {
  // Save file
  // auto append trailing "\n"
  int buff_end;
  buff_end = buff->length();
  char last_char;
  last_char = buff->char_at(buff_end - 1);
  if (last_char != 10) {
    buff->append("\n");
    edit->insert_position(buff_end + 1);
    edit->show_insert_position();
  }
  // fl_alert("Saving to file %s", newfile);
  if (buff->savefile(newfile)) {
    fl_alert("Error writing to file \'%s\':\n%s.", newfile, strerror(errno));
  } else {
    strcpy(filename, newfile);
    strcpy(title, newfile);
    win->label(title);
    changed = false;
    #ifdef __linux__
      char chmod[FL_PATH_MAX + 9];
      sprintf(chmod, "chmod +x %s", newfile);
      system(chmod);
    #endif
  }
}

void saveas_cb() {
  char *sfa;
  sfa = fl_file_chooser("Save File As ?", "*", filename);
  if(sfa != NULL) save_file(sfa);
}

void save_cb() {
  if (filename[0] == 0) {
    // No filename
    saveas_cb();
  } else {
    save_file(filename);
  }
}

void open_cb() {
  if (!check_saved()) return;
  char *newfile = fl_file_chooser("Open File ?", "*", filename);
  if (newfile != NULL) load_file(newfile);
}

void load_file(char *newfile) {
  bool color_resume = color;
  if (color_resume) { // disable color before loading
    color_cb();
  }
  int lf;
  lf = buff->loadfile(newfile);
  if (lf) {
    fl_alert("Error while loading file \'%s\':\n%s.", newfile, strerror(errno));
    if (color_resume) color_cb();
  } else {
    strcpy(filename, newfile);
    strcpy(title, newfile);
    win->label(title);
    changed = false;
    if (color_resume) color_cb();
  }
}

void style_unfinished_cb(int, void*) {
// call back for highlight data
// if style 'A' is found,
// this call back will be called.
// void *cbArg will be passed as arguement

// fl_alert("style_unfinished_cb");
}

void busybox(char *textbuff, char *scanned_text) {
// busybox
// List of known busybox commands...
// https://busybox.net/downloads/BusyBox.html

  const char *applets[] = {
    "acpid",
    "addgroup",
    "adduser",
    "adjtimex",
    "ar",
    "arp",
    "arping",
    "ash",
    "awk",
    "basename",
    "beep",
    "blkid",
    "brctl",
    "bunzip2",
    "busybox",
    "bzcat",
    "bzip2",
    "cal",
    "cat",
    "catv",
    "chat",
    "chattr",
    "chgrp",
    "chmod",
    "chown",
    "chpasswd",
    "chpst",
    "chroot",
    "chrt",
    "chvt",
    "cksum",
    "clear",
    "cmp",
    "comm",
    "cp",
    "cpio",
    "crond",
    "crontab",
    "cryptpw",
    "cut",
    "date",
    "dc",
    "dd",
    "deallocvt",
    "delgroup",
    "deluser",
    "depmod",
    "devmem",
    "df",
    "dhcprelay",
    "diff",
    "dirname",
    "dmesg",
    "dnsd",
    "dnsdomainname",
    "dos2unix",
    "dpkg",
    "du",
    "dumpkmap",
    "dumpleases",
    "echo",
    "ed",
    "egrep",
    "eject",
    "env",
    "envdir",
    "envuidgid",
    "expand",
    "expr",
    "fakeidentd",
    "false",
    "fbset",
    "fbsplash",
    "fdflush",
    "fdformat",
    "fdisk",
    "fgrep",
    "find",
    "findfs",
    "flash_lock",
    "flash_unlock",
    "fold",
    "free",
    "freeramdisk",
    "fsck",
    "fsck.minix",
    "fsync",
    "ftpd",
    "ftpget",
    "ftpput",
    "fuser",
    "getopt",
    "getty",
    "grep",
    "gunzip",
    "gzip",
    "hd",
    "hdparm",
    "head",
    "hexdump",
    "hostid",
    "hostname",
    "httpd",
    "hush",
    "hwclock",
    "id",
    "ifconfig",
    "ifdown",
    "ifenslave",
    "ifplugd",
    "ifup",
    "inetd",
    "init",
    "inotifyd",
    "insmod",
    "install",
    "ionice",
    "ip",
    "ipaddr",
    "ipcalc",
    "ipcrm",
    "ipcs",
    "iplink",
    "iproute",
    "iprule",
    "iptunnel",
    "kbd_mode",
    "kill",
    "killall",
    "killall5",
    "klogd",
    "last",
    "length",
    "less",
    "linux32",
    "linux64",
    "linuxrc",
    "ln",
    "loadfont",
    "loadkmap",
    "logger",
    "login",
    "logname",
    "logread",
    "losetup",
    "lpd",
    "lpq",
    "lpr",
    "ls",
    "lsattr",
    "lsmod",
    "lzmacat",
    "lzop",
    "lzopcat",
    "makemime",
    "man",
    "md5sum",
    "mdev",
    "mesg",
    "microcom",
    "mkdir",
    "mkdosfs",
    "mkfifo",
    "mkfs.minix",
    "mkfs.vfat",
    "mknod",
    "mkpasswd",
    "mkswap",
    "mktemp",
    "modprobe",
    "more",
    "mount",
    "mountpoint",
    "mt",
    "mv",
    "nameif",
    "nc",
    "netstat",
    "nice",
    "nmeter",
    "nohup",
    "nslookup",
    "od",
    "openvt",
    "passwd",
    "patch",
    "pgrep",
    "pidof",
    "ping",
    "ping6",
    "pipe_progress",
    "pivot_root",
    "pkill",
    "popmaildir",
    "printenv",
    "printf",
    "ps",
    "pscan",
    "pwd",
    "raidautorun",
    "rdate",
    "rdev",
    "readlink",
    "readprofile",
    "realpath",
    "reformime",
    "renice",
    "reset",
    "resize",
    "rm",
    "rmdir",
    "rmmod",
    "route",
    "rpm",
    "rpm2cpio",
    "rtcwake",
    "run-parts",
    "runlevel",
    "runsv",
    "runsvdir",
    "rx",
    "script",
    "scriptreplay",
    "sed",
    "sendmail",
    "seq",
    "setarch",
    "setconsole",
    "setfont",
    "setkeycodes",
    "setlogcons",
    "setsid",
    "setuidgid",
    "sh",
    "sha1sum",
    "sha256sum",
    "sha512sum",
    "showkey",
    "slattach",
    "sleep",
    "softlimit",
    "sort",
    "split",
    "start-stop-daemon",
    "stat",
    "strings",
    "stty",
    "su",
    "sulogin",
    "sum",
    "sv",
    "svlogd",
    "swapoff",
    "swapon",
    "switch_root",
    "sync",
    "sysctl",
    "syslogd",
    "tac",
    "tail",
    "tar",
    "taskset",
    "tcpsvd",
    "tee",
    "telnet",
    "telnetd",
    "test",
    "tftp",
    "tftpd",
    "time",
    "timeout",
    "top",
    "touch",
    "tr",
    "traceroute",
    "true",
    "tty",
    "ttysize",
    "udhcpc",
    "udhcpd",
    "udpsvd",
    "umount",
    "uname",
    "uncompress",
    "unexpand",
    "uniq",
    "unix2dos",
    "unlzma",
    "unlzop",
    "unzip",
    "uptime",
    "usleep",
    "uudecode",
    "uuencode",
    "vconfig",
    "vi",
    "vlock",
    "volname",
    "watch",
    "watchdog",
    "wc",
    "wget",
    "which",
    "who",
    "whoami",
    "xargs",
    "yes",
    "zcat",
    "zcip"
  };
  /*
  compare_keywords(
  address_to_buff,
  array,
  sizeof_array,
  address_to_result,
  color_style(A~K)
  */
  compare_keywords(
    &textbuff[0],
    applets,
    sizeof(applets)/sizeof(*applets),
    &scanned_text[0],
    66
  );
}

void bourne_builtins(char *textbuff, char *scanned_text) {
// const char *bourne_variables[] = { // List of known bourne shell built-in variables...
//   "~",
//   "HOME",
//   "IFS",
//   "OPTARG",
//   "OPTIND",
//   "PATH",
//   "PS1",
//   "PS2",
//   "PWD",
//   "SHLVL"
// };

  // bourne_builtins
  const char *bourne_function[] = { // List of known bourne shell built-in functions...
    "alias",
    "break",
    "cd",
    "continue",
    "eval",
    "exec",
    "exit",
    "export",
    "getopts",
    "hash",
    "pwd",
    "read",
    "readonly",
    "return",
    "shift",
    "source",
    "test",
    "times",
    "trap",
    "umask",
    "unset"
  };
  const char *bourne_constructs[] = { // List of known bourne shell constructs...
    "case",
    "do",
    "done",
    "elif",
    "esac",
    "fi",
    "for",
    "if",
    "in",
    "select",
    "then",
    "until",
    "while"
  };
  /*
  compare_keywords(
  address_to_buff,
  array,
  sizeof_array,
  address_to_result,
  color_style(A~K)
  */
  compare_keywords(
    &textbuff[0],
    bourne_function,
    sizeof(bourne_function)/sizeof(*bourne_function),
    &scanned_text[0],
    68
  );
  compare_keywords(
    &textbuff[0],
    bourne_constructs,
    sizeof(bourne_constructs)/sizeof(*bourne_constructs),
    &scanned_text[0],
    75
  );
}

int is_special(char ascii) {
  // 33~47, 58~64, 91~96, 123~126
  if (ascii == 95) {
    // 95 _ usually treated as normal string
    // only exception $_
    // already handled
    return 0;
  }
  if (ascii > 32 && ascii < 48) {
    return 1;
  }
  if (ascii > 57 && ascii < 65) {
    return 2;
  }
  if (ascii > 90 && ascii < 97) {
    return 3;
  }
  if (ascii > 122 && ascii < 127) {
    return 4;
  }
  return 0;
// Just a bunch of special characters
// Old bloated codes
// const char *special_characters[] = {
//   "!", // 33
//   "\"", // 34
//   "#", // 35
//   "$", // 36
//   "%", // 37
//   "&", // 38
//   "\'", // 39
//   "(", // 40
//   ")", // 41
//   "*", // 42
//   "+", // 43
//   ",", // 44
//   "-", // 45
//   ".", // 46
//   "/", // 47
//   ":", // 58
//   ";", // 59
//   "<", // 60
//   "=", // 61
//   ">", // 62
//   "\?", // 63
//   "@", // 64
//   "[", // 91
//   "\\", // 92
//   "]", // 93
//   "^", // 94
//   "_", // 95 usually treated as normal string
//   "`", // 96
//   "{", // 123
//   "|", // 124
//   "}" // 125
//   "~" // 126 $HOME
// };
// size_t list_size, prb;
// list_size = sizeof(special_characters) / sizeof(*special_characters);

// assign probe
// const char *probe;
// probe = special_characters[0];

// convert to pointer
// const char *cmp;
// cmp = &ascii;

// for (prb = 0; prb < list_size; prb++) {
//   if (strcmp(cmp, probe) == 0) return 1;
//   *probe++;
// }
// return 0;
}

void use_coloring() {
  // associate style & buffer
  edit->highlight_data(
    stylebuf,
    styletable,
    sizeof(styletable) / sizeof(styletable[0]),
    'A',
    style_unfinished_cb,
    (void*)0
  );
  // buff->add_modify_callback(style_update, edit);
  // buff->add_modify_callback(modification_cb, edit);
}

void disable_color() {
  // buff->remove_modify_callback(modification_cb, edit);
  // hopefully disable the style thing
  stylebuf->text("");
  // edit->highlight_data(NULL, NULL, NULL, NULL, NULL);
}

void auto_indent_switch() {
  auto_indent = !auto_indent;
  if (auto_indent) {
    indent_switch->label("No  Indent");
  } else {
    indent_switch->label("AutoIndent");
  }
}

void stylebuf_init() {
  // buff_copy
  char *buff_copy;
  buff_copy = buff->text(); // full copy
  int bufflen;
  if (buff_copy) {
    bufflen = strlen(buff_copy); // end_pos + 1
  } else {
    fl_alert("buff_copy malloc failed");
    return;
  }
  
  char *scan;
  scan = (char*)malloc(bufflen+1);
  if (scan) {
    memset(scan, 65, bufflen); // 'A'
    scan[bufflen] = 0; // '\0'
  } else {
    fl_alert("scan malloc failed");
    free(buff_copy);
    return;
  }
  
  /*
  // compare keywords
  busybox(&buff_copy[0], &scan[0]);
  bourne_builtins(&buff_copy[0], &scan[0]);
  */
  bool cm = false; // #comment 35
  bool es = false; // \escapes 92
  bool ds = false; // $dolor_sign 36
  bool se = false; // ${shell expansion}, ds must be true
  bool bq = false; // `back quote command substitution` 96
  bool sq = false; // 'single quote' 39
  bool dq = false; // "double quote" 34
  int cs = 0; // $(command substitution)
  int p = 0; // (parentheses) 40 41
  // int sb = 0; // [square brackets] 91 93
  // int cb = 0; // {curly brackets} 123 125
  // Debug
  /*
  fl_alert("buff_copy:%s", buff_copy);
  fl_alert("scan:%s", scan);
  */
  // compare keywords
  busybox(&buff_copy[0], &scan[0]);
  bourne_builtins(&buff_copy[0], &scan[0]);
  // Debug
  /*
  fl_alert("After keyword");
  fl_alert("buff_copy:%s", buff_copy);
  fl_alert("scan:%s", scan);
  */
  int j = 0;
  
  for (;j < bufflen; j++) {
    switch(buff_copy[j]) {
      case 10: // newline
        if (cm) cm = !cm;
      case 9: // tab
      case 32: // space
        if (ds) ds = !ds;
        scan[j] = buff_copy[j];
        continue;
      case 35: // #comment
        if (!ds && !sq && !dq && !se) {
          cm = true;
          scan[j] = 'J';
        }
        break;
      case 92: // \escapes
        if (!cm && !sq) es = true;
        break; // other escape
      case 39: // 'single quote'
        if (cm) break;
        // single quote is always
        // treated literally in double quote
        if (!dq) {
          sq = !sq;
          scan[j] = 'F';
          continue;
        }
        break;
      case 34: // "double quote"
        if (cm) break;
        if (!sq) {
          dq = !dq;
          scan[j] = 'G';
          if (ds) ds = !ds;
          continue;
        }
        break;
      case 96: // `back quote`
        if (cm || sq) break;
        scan[j] = 'E';
        ds = false;
        bq = !bq;
        break;
      case 36: // $dolor_sign
        if (cm || sq) break;
        ds = true;
        switch(buff_copy[j+1]) {
          case 33: // built-in variable $!
          case 35: // built-in variable $#
          case 36: // built-in variable $$
          case 42: // built-in variable $*
          case 45: // built-in variable $-
          case 63: // built-in variable $?
          case 64: // built-in variable $@
          case 95: // built-in variable $_
            scan[j] = 'I';
            j++;
            scan[j] = 'I';
            ds = false;
            continue;
          case 40: // $(...
            cs++;
            p++;
            scan[j] = 'E';
            j++;
            scan[j] = 'E';
            ds = false;
            continue;
          case 123: // shell expansion ${
            // cb++;
            se = true; // a bit redundant
            scan[j] = 'I';
            j++;
            scan[j] = 'I';
            ds = true;
            continue;
          case 9: // tab
          case 10: // newline
          case 32: // space
          case 47: // regular expression /$/
            // trailing dolor_sign$
            ds = false;
            // resume default
            scan[j] = 'A';
            continue;
        }
        scan[j] = 'I';
        if (is_special(buff_copy[j+1])) {
          // invalid variable $, or such
          // resume default
          ds = false;
          scan[j] = 'A';
        }
        break;
      case 40: // (
        if (cm || sq || dq) break;
        p++;
        scan[j] = 'C';
        break;
      case 41: // )
        if (cm || sq) break;
        if (ds) ds = !ds;
        if (dq) {
          if (cs == 0)
          break;
        }
        p--;
        scan[j] = 'C';
        break;
      case 123: // {
        scan[j] = 'C';
        break;
      case 125: // }
        if (cm || sq) break;
        if (ds || se) {
          // end of variable
          ds = false;
          se = false;
          scan[j] = 'I';
          continue;
        }
        scan[j] = 'C';
        break;
      default:
        if (cm || es || sq) break;
        // scan[j] = 'A'; --> overwrite the keywords
        if (is_special(buff_copy[j])) scan[j] = 'C';
    }
    if (se) {
      scan[j] = 'I';
      continue;
    }
    if (cm) {
      switch (buff_copy[j]) {
        case 10: // newline
          cm = false;
        case 9: // tab
        case 32: // space
          scan[j] = buff_copy[j];
          break;
        default:
          scan[j] = 'J';
      }
      continue;
    }
    if (sq) {
      // 'single quote' ignore escapes
      scan[j] = 'F';
      if (buff_copy[j] == 39) sq = !sq;
      continue;
    }
    if (dq) scan[j] = 'G';
    if (ds) {
      scan[j] = 'I';
      if (is_special(buff_copy[j+1])) {
        // end of variable
        ds = false;
        continue;
      }
    }
    if (es) {
      // this char = backslash (92)
      if (buff_copy[j+1]) {
        // char not null
        scan[j] = 'H';
        scan[j+1] = 'H';
      }
      if (dq && buff_copy[j+1] == 39) {
        // echo "\'" --> \'
        es = false;
        continue;
      }
      if (buff_copy[j+1] == 120) {
        // hex \xFF 48~57, 65~70, 97~102
        bool hex = ((
          (buff_copy[j+2] > 47 && buff_copy[j+2] < 58) ||
          (buff_copy[j+2] > 64 && buff_copy[j+2] < 71) ||
          (buff_copy[j+2] > 96 && buff_copy[j+2] < 103)
        ) && (
          (buff_copy[j+3] > 47 && buff_copy[j+3] < 58) ||
          (buff_copy[j+3] > 64 && buff_copy[j+3] < 71) ||
          (buff_copy[j+3] > 96 && buff_copy[j+3] < 103)
        ));
        if (hex) {
          scan[j+2] = 'H';
          scan[j+3] = 'H';
          j+=2;
        }
      }
      j++;
      es = false;
      continue;
    }
    if (cs>0) {
      if (scan[j] == 'A') scan[j] = 'E';
      if (buff_copy[j] == 41) {
        // )
        scan[j] = 'E';
        cs--;
        if (p > cs) cs++;
      }
      // continue;
    }
    if (bq) {
      if (scan[j] == 'A') scan[j] = 'E';
      // continue;
    }
  }
  /*
  fl_alert("Before init");
  fl_alert("buff_copy:%s", buff_copy);
  fl_alert("scan:%s", scan);
  */
  stylebuf->text(scan);
  /*
  fl_alert("Write to buff");
  fl_alert("%s", stylebuf->text());
  */
  free(buff_copy);
  free(scan);
// KeyWord Debug
// for (;j < bufflen; j++) {
//   switch(buff_copy[j]) {
//     case 10: // newline
//       if (cm) cm = !cm;
//     case 9: // tab
//     case 32: // space
//       if (ds) ds = !ds;
//       scan[j] = buff_copy[j];
//   }
// }

}

void color_cb() {
  color = !color;
  if (color) {
    stylebuf_init();
    // scan_forward(0);
    // use_coloring();
    color_switch->label("NoColor");
  } else {
    disable_color();
    color_switch->label("Colorful");
    // edit->redisplay_range(0, buff->length());
  }
  edit->redisplay_range(0, buff->length());
}

int auto_indent_cb(int lsp, int pos, char *line) {
// lsp: line start pos
// pos: insert position
// line: entire line

  int current_pos = pos + 1; // '\n'
  char *indention; // '\n'space'\0'
  indention = new char[current_pos - lsp]; // [pos - lsp + 1]
  int ai = 0;
  for (;ai < (current_pos - lsp);ai++) {
    // tab || space
    if (line[ai] == 9 || line[ai] == 32) indention[ai] = line[ai];
    else break;
  }
  if (ai == 0) {
    if (color) {
      indention[0] = 10; // '\n'
      indention[0] = 0; // '\0'
      stylebuf->replace(current_pos, current_pos, indention);
    }
    delete[] indention;
    free(line);
    return current_pos;
  }
  indention[ai] = 0; // '\0'
  buff->insert(current_pos, indention); // will call modification_cb
  // stylebuf is one char slower than buff
  current_pos += strlen(indention);
  if (color) {
    // modification_cb already handle the inserted '\n', using "replace"
    stylebuf->replace(pos + 1, current_pos, indention);
  }
  delete[] indention;
  free(line);
  return current_pos - 1;
}

void compare_keywords(char *text, const char *keys[], int elements, char *result, int ascii) {
// old code called after style
// int needle_len = strlen(needle);
// bool bos = true; // begin of string
// while (1) {
  // match first char
//   while(*text != *needle) {
//     bos = false;
//     *text++;
//     *result++;
//     if (*text == 0) {
      // end of string
//       return;
//     }
//   }
//   if (*result == 70 || *result == 71 || *result == 74) {
    // F - Single Quotes
    // G - Double Quotes
    // J - comments
//     bos = false;
//     *text++;
//     *result++;
//     continue;
//   }
//   int nl = 1; // needle[0] already matched
//   for (; nl < needle_len; nl++) {
//     if (text[nl] != needle[nl]) {
//       bos = false;
//       *(text += nl);
//       *(result += nl);
//       break;
//     }
//   }
  // all matched
//   if (nl == needle_len) {
    // check anterior
//     if (!bos) {
      // skip begin of string
//       switch (*(text - 1)) {
//         case 9: // tab
//         case 32: // space
//         case 38: // &
//         case 40: // (
//         case 59: // ;
//         case 60: // <
//         case 62: // >
//         case 96: // `
//         case 124: // |
//           break;
//         default:
//           *(text += nl);
//           *(result += nl);
//           continue;
//       }
//     }
    // check posterior
//     switch (text[nl]) {
//       case 0: // end of string
//       case 9: // tab
//       case 10: // newline
//       case 32: // space
//       case 38: // &
//       case 41: // )
//       case 59: // ;
//       case 60: // <
//       case 62: // >
//       case 96: // `
//       case 124: // |
//         break;
//       default:
//         bos = false;
//         *(text += nl);
//         *(result += nl);
//         continue;
//     }
//     for (; nl > 0; nl--) {
//       *result = ascii;
//       *text++;
//       *result++;
//     }
//   }
// }
// old code V2
// const char *needle;
// bool matched = true;
// size_t nl = 0;
// size_t textlen = strlen(text);
// matching leading char
// size_t i = 0;
// for (; i < elements; i++) {
//   needle = keys[i];
//   nl = strlen(needle);
//   if (textlen < nl) {
    // next keyword
//     continue;
//   }
  // matching first char
//   if (*text == *needle) {
    // check posterior
//     switch (text[nl]) {
//       case 0: // end of string
//       case 9: // tab
//       case 10: // newline
//       case 32: // space
//       case 38: // &
//       case 41: // )
//       case 59: // ;
//       case 60: // <
//       case 62: // >
//       case 96: // `
//       case 124: // |
//         break;
//       default:
        // next keyword
//         continue;
//     }
    // string length matched
//     size_t j = 1; // first char already matched
//     for (; j < nl; j++) {
      // matching
//       if (text[j] != needle[j]) {
        // next element
//         matched = false;
//         break;
//       }
//     }
//     if (matched) {
//       for (; nl > 0; nl--) {
//         *result = ascii;
//         textlen--;
//         result++;
//         text++;
//       }
      // breaking element loop
//       break;
//     }
    // else: stay at current text pos
//   }
// }
// do {
  // check anterior
//   switch (*text) {
//     case 9: // tab
//     case 10: // newline
//     case 32: // space
//     case 38: // &
//     case 40: // (
//     case 59: // ;
//     case 60: // <
//     case 62: // >
//     case 96: // `
//     case 124: // |
      // if next char is A-Z/a-z
//       if (text[1] > 96 && text[1] < 123) {
        // all keywords are in lowercase
//         textlen--;
//         result++;
//         text++;
//         break;
//       }
//     default:
//       textlen--;
//       result++;
      // *text++ by while
//       continue;
//   }
//   size_t k = 0;
//   for (; k < elements; k++) {
//     needle = keys[k];
//     nl = strlen(needle);
//     if (textlen < nl) {
      // next keyword
//       continue;
//     }
    // matching first char
//     if (*text == *needle) {
      // check posterior
//       switch (text[nl]) {
//         case 0: // end of string
//         case 9: // tab
//         case 10: // newline
//         case 32: // space
//         case 38: // &
//         case 41: // )
//         case 59: // ;
//         case 60: // <
//         case 62: // >
//         case 96: // `
//         case 124: // |
//           break;
//         default:
          // next keyword
//           continue;
//       }
//       matched = true;
      // string length matched
//       size_t l = 1; // first char already matched
//       for (; l < nl; l++) {
        // matching
//         if (text[l] != needle[l]) {
          // next element
//           matched = false;
//           break;
//         }
//       }
//       if (matched) {
//         for (; nl > 0; nl--) {
//           *result = ascii;
//           textlen--;
//           result++;
//           text++;
//         }
        // stay at current text pos
//         textlen++;
//         result--;
//         text--;
        // breaking element loop
//         break;
//       }
      // else: stay at current text pos
//     }
//   }
//   textlen--;
//   result++;
  // *text++ by while
// } while (*text++);
  const char *needle;
  bool matched = false;
  int loop_nb = 0;
  /*
  size_t nl; // needle length
  size_t textlen = strlen(text);
  size_t k;
  size_t l;
  */
  int nl; // needle length
  int textlen = strlen(text);
  int k;
  int l;
  
  do {
    // check anterior, skip first char
    if (loop_nb) {
      switch (*text) {
        case 9: // tab
        case 10: // newline
        case 32: // space
        case 38: // &
        case 40: // (
        case 59: // ;
        case 60: // <
        case 62: // >
        case 96: // `
        case 124: // |
          // if next char is A-Z/a-z
          if (text[1] > 96 && text[1] < 123) {
            // all keywords are in lowercase
            textlen--;
            result++;
            text++;
            break;
          }
        default:
          textlen--;
          result++;
          // *text++ by while
          continue;
      }
    }
    loop_nb++;
    for (k = 0; k < elements; k++) {
      needle = keys[k];
      nl = strlen(needle);
      if (textlen < nl) {
        // next keyword
        continue;
      }
      // matching first char
      if (*text == *needle) {
        // check posterior
        switch (text[nl]) {
          case 0: // end of string
          case 9: // tab
          case 10: // newline
          case 32: // space
          case 38: // &
          case 41: // )
          case 59: // ;
          case 60: // <
          case 62: // >
          case 96: // `
          case 124: // |
            break;
          default:
            // next keyword
            continue;
        }
        matched = true;
        // string length matched
        // l = 1 --> first char already matched
        for (l = 1; l < nl; l++) {
          // matching
          if (text[l] != needle[l]) {
            // next element
            matched = false;
            break;
          }
        }
        if (matched) {
          for (; nl > 0; nl--) {
            *result = ascii;
            textlen--;
            result++;
            text++;
          }
          // stay at current text pos
          textlen++;
          result--;
          text--;
          // breaking element loop
          break;
        }
        // else: stay at current text pos
      }
    }
    textlen--;
    result++;
    // *text++ by while
  } while (*text++);
}

void modification_cb(int pos, int nInserted, int nDeleted, int nRestyled, const char *deletedText, void *cbArg) {
  if (nInserted == 0 && nDeleted == 0) {
    // selection change
    stylebuf->unselect();
    return;
  }
  if (nInserted > 0 && nDeleted > 0) {
    // This only happens when a user undo changes
    // do nothing...
    return;
  }
  if (!changed) {
    // adjust title
    changed = true;
    strcat(title, "*");
    win->label(title);
  }
  // different from pos, a current working pos
  int current_pos = pos;
  if (auto_indent && nInserted == 1 && buff->char_at(pos) == 10) {
    indenting = true;
    current_pos = auto_indent_cb(
      buff->line_start(pos),
      pos, // insert position
      buff->line_text(pos)
    );
    edit->insert_position(current_pos);
    return;
  }
  if (color) {
    // Debug
    /*
    fl_alert("pos:%d\nnInserted:%d\nnDeleted:%d\nnRestyled:%d\ndeletedText:\n%s",
    pos, nInserted, nDeleted, nRestyled, deletedText);
    fl_alert("current buffer: '%c'\ncurrent style: '%c' \ncurrent_pos: '%d'",
    buff->char_at(pos), stylebuf->char_at(pos), current_pos);
    */
    int scan_pos; // line_start_pos
    if (buff->char_at(pos) == 10) {
      scan_pos = pos + 1;
    } else {
      scan_pos = buff->line_start(pos);
    }
    if (indenting) {
      indenting = false;
      scan_pos = buff->line_start(scan_pos - 2);
    }
    // I'm lazy
    stylebuf_init();
    edit->redisplay_range(0, buff->length());
    // edit->redisplay_range(current_pos, buff->length());
    edit->insert_position(current_pos);
    edit->show_insert_position();
    return;
// catch exception
    if (buff->length() != stylebuf->length()) {
      fl_alert(
        "!!!Exception occur!!!\nbuff->length = %d\nstylebuf->length = %d", // \nForcing reload...",
        buff->length(),
        stylebuf->length()
      );
      /*
      color_cb();
      color_cb();
      */
      // Debug
      fl_alert("pos:%d\nnInserted:%d\nnDeleted:%d\nnRestyled:%d\ndeletedText:\n%s",
      pos, nInserted, nDeleted, nRestyled, deletedText);
      fl_alert("current buffer: '%c'\ncurrent style: '%c' \ncurrent_pos: '%d'",
      buff->char_at(pos), stylebuf->char_at(pos), current_pos);
    }
  }
}

void close_cb(Fl_Widget*, void* v) {
  if (check_saved()) exit(0);
}

void ts_cb() {
  fl_alert("%d", buff->length());
  fl_alert("%s", buff->text());
}

void ss_cb() {
  fl_alert("%d", stylebuf->length());
  fl_alert("%s", stylebuf->text());
}

Fl_Double_Window *win=(Fl_Double_Window *)0;

Fl_Text_Editor *edit=(Fl_Text_Editor *)0;

Fl_Menu_Bar *menu_bar=(Fl_Menu_Bar *)0;

static void cb_new_bt(Fl_Menu_*, void*) {
  new_cb();
}

static void cb_open(Fl_Menu_*, void*) {
  open_cb();
}

static void cb_save(Fl_Menu_*, void*) {
  save_cb();
}

static void cb_saveas(Fl_Menu_*, void*) {
  saveas_cb();
}

static void cb_sh(Fl_Menu_*, void*) {
  SHELL = "#!/bin/sh\n";
  shebang();
}

static void cb_bash(Fl_Menu_*, void*) {
  SHELL = "#!/usr/bin/env bash\n";
  shebang();
}

static void cb_plain_text(Fl_Menu_*, void*) {
  SHELL = "";
}

static void cb_color_switch(Fl_Menu_*, void*) {
  color_cb();
}

static void cb_indent_switch(Fl_Menu_*, void*) {
  auto_indent_switch();
}

static void cb_ts_btn(Fl_Menu_*, void*) {
  ts_cb();
}

static void cb_ss_btn(Fl_Menu_*, void*) {
  ss_cb();
}

Fl_Menu_Item menu_menu_bar[] = {
 {"&File", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&New File", 0x4006e,  (Fl_Callback*)cb_new_bt, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Open", 0x4006f,  (Fl_Callback*)cb_open, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Save", 0x40073,  (Fl_Callback*)cb_save, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Save &As", 0x50073,  (Fl_Callback*)cb_saveas, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&Shell", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"POSIX sh", 0x80073,  (Fl_Callback*)cb_sh, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"ENV bash", 0x80062,  (Fl_Callback*)cb_bash, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Plain text", 0,  (Fl_Callback*)cb_plain_text, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Colorful", 0,  (Fl_Callback*)cb_color_switch, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Auto Indent", 0,  (Fl_Callback*)cb_indent_switch, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Text size", 0,  (Fl_Callback*)cb_ts_btn, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Style size", 0,  (Fl_Callback*)cb_ss_btn, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

int main(int argc, char **argv) {
  { win = new Fl_Double_Window(425, 320);
    win->box(FL_PLASTIC_UP_BOX);
    { edit = new Fl_Text_Editor(1, 29, 424, 288);
      edit->box(FL_PLASTIC_DOWN_FRAME);
      edit->textfont(4);
      edit->textsize(20);
      Fl_Group::current()->resizable(edit);
    } // Fl_Text_Editor* edit
    { menu_bar = new Fl_Menu_Bar(0, 0, 425, 30);
      menu_bar->box(FL_PLASTIC_UP_BOX);
      menu_bar->down_box(FL_PLASTIC_DOWN_BOX);
      menu_bar->menu(menu_menu_bar);
    } // Fl_Menu_Bar* menu_bar
    win->end();
  } // Fl_Double_Window* win
  // editor init
  win->label(title);
  buffer_init();
  use_coloring();
  // if (argc > 1) load_file(argv[1]);
  win->callback((Fl_Callback *)close_cb, win);
  win->show(argc, argv);
  return Fl::run();
}
