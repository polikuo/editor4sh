// author polikuo 2018
// generated by Fast Light User Interface Designer (fluid) version 1.0304

#include "editor.h"
char const *SHELL = "#!/bin/sh\n"; 
char filename[FL_PATH_MAX], title[FL_PATH_MAX]; 
Fl_Text_Buffer *buff = new Fl_Text_Buffer(); 

void buffer_init(void) {
  // attach buffer to  editor
  buff->text(SHELL);
  edit->buffer(buff);
  edit->insert_position(10);
  edit->show_insert_position();
}

void shebang(void) {
  int firstline, current_pos;
  current_pos = edit->insert_position();
  // search_forward(int startPos, const char *searchString, int *foundPos, int matchCase = 0)
  int found = buff->search_forward(0, "\n", &firstline);
  if (found) {
    buff->select(0, firstline+1);
    buff->remove_selection();
    buff->insert(0, SHELL);
    edit->insert_position(current_pos + strlen(SHELL) - firstline - 1);
    edit->show_insert_position();
  } else {
    // no newline char
    buff->text(SHELL);
    edit->insert_position(strlen(SHELL));
    edit->show_insert_position();
  }
}

void new_cb() {
  buff->text(SHELL);
  strcpy(filename, "\0");
  strcpy(title, "\0");
  win->label(title);
  // coloring
  color_cb();
  /*
  if (color) {
    buff_init();
    use_coloring();
    color_switch->label("NoColor");
  } else {
    disable_color();
    color_switch->label("Colorful");
    edit->redisplay_range(0, buff->length());
  }
  */
}

void save_file(const char *newfile) {
  // Save file
  // auto append trailing "\n"
  int buff_end;
  buff_end = buff->length();
  char last_char;
  last_char = buff->char_at(buff_end - 1);
  if (last_char != 10) {
    buff->append("\n");
    edit->insert_position(buff_end + 1);
    edit->show_insert_position();
  }
  // fl_alert("Saving to file %s", newfile);
  if (buff->savefile(newfile)) {
    fl_alert("Error writing to file \'%s\':\n%s.", newfile, strerror(errno));
  } else {
    strcpy(filename, newfile);
    strcpy(title, newfile);
    win->label(title);
    #ifdef __linux__
      char chmod[FL_PATH_MAX + 9];
      sprintf(chmod, "chmod +x %s", newfile);
      system(chmod);
    #endif
  }
}

void saveas_cb(void) {
  char *sfa;
  sfa = fl_file_chooser("Save File As ?", "*", filename);
  if(sfa != NULL) save_file(sfa);
}

void save_cb(void) {
  if (filename[0] == '\0') {
    // No filename
    saveas_cb();
  } else {
    save_file(filename);
  }
}

void open_cb() {
  char *newfile = fl_file_chooser("Open File ?", "*", filename);
  if (newfile != NULL) load_file(newfile);
}

void load_file(char *newfile) {
  int lf;
  lf = buff->loadfile(newfile);
  if (lf) {
    fl_alert("Error while loading file \'%s\':\n%s.", newfile, strerror(errno));
  } else {
    strcpy(filename, newfile);
    strcpy(title, newfile);
    win->label(title);
    color_cb();
  }
}
bool color = false; 
Fl_Text_Buffer *stylebuf = new Fl_Text_Buffer(); 
#define TS 14
// Style table
// A - Plain
// B - busybox
// C - special_characters
// D - bourne_function
// E - bourne_constructs
// F - Single Quotes
// G - Double Quotes
// H - escapes
// I - bourne_variables
// J - comments
Fl_Text_Display::Style_Table_Entry styletable[] = {
  { FL_BLACK,FL_COURIER,TS },
  { FL_DARK_CYAN,FL_COURIER_BOLD, TS },
  { FL_DARK_YELLOW,FL_COURIER_BOLD, TS },
  { FL_BLUE, FL_COURIER_BOLD, TS },
  { FL_DARK_BLUE, FL_COURIER_BOLD, TS },
  { FL_GREEN, FL_COURIER,TS },
  { FL_DARK_GREEN, FL_COURIER,TS },
  { FL_BLUE,FL_COURIER,TS },
  { FL_DARK_RED, FL_COURIER_BOLD, TS },
  { FL_GRAY, FL_COURIER_ITALIC, TS }
}; 

void style_unfinished_cb(int, void*) {
// NULL call back for highlight data
// fl_alert("style_unfinished_cb");
  // fl_alert("style_unfinished_cb");
}

const char * busybox() {
// busybox
// List of known busybox commands...
// https://busybox.net/downloads/BusyBox.html

  const char *applets[] = {
    "acpid",
    "addgroup",
    "adduser",
    "adjtimex",
    "ar",
    "arp",
    "arping",
    "ash",
    "awk",
    "basename",
    "beep",
    "blkid",
    "brctl",
    "bunzip2",
    "busybox",
    "bzcat",
    "bzip2",
    "cal",
    "cat",
    "catv",
    "chat",
    "chattr",
    "chgrp",
    "chmod",
    "chown",
    "chpasswd",
    "chpst",
    "chroot",
    "chrt",
    "chvt",
    "cksum",
    "clear",
    "cmp",
    "comm",
    "cp",
    "cpio",
    "crond",
    "crontab",
    "cryptpw",
    "cut",
    "date",
    "dc",
    "dd",
    "deallocvt",
    "delgroup",
    "deluser",
    "depmod",
    "devmem",
    "df",
    "dhcprelay",
    "diff",
    "dirname",
    "dmesg",
    "dnsd",
    "dnsdomainname",
    "dos2unix",
    "dpkg",
    "du",
    "dumpkmap",
    "dumpleases",
    "echo",
    "ed",
    "egrep",
    "eject",
    "env",
    "envdir",
    "envuidgid",
    "expand",
    "expr",
    "fakeidentd",
    "false",
    "fbset",
    "fbsplash",
    "fdflush",
    "fdformat",
    "fdisk",
    "fgrep",
    "find",
    "findfs",
    "flash_lock",
    "flash_unlock",
    "fold",
    "free",
    "freeramdisk",
    "fsck",
    "fsck.minix",
    "fsync",
    "ftpd",
    "ftpget",
    "ftpput",
    "fuser",
    "getopt",
    "getty",
    "grep",
    "gunzip",
    "gzip",
    "hd",
    "hdparm",
    "head",
    "hexdump",
    "hostid",
    "hostname",
    "httpd",
    "hush",
    "hwclock",
    "id",
    "ifconfig",
    "ifdown",
    "ifenslave",
    "ifplugd",
    "ifup",
    "inetd",
    "init",
    "inotifyd",
    "insmod",
    "install",
    "ionice",
    "ip",
    "ipaddr",
    "ipcalc",
    "ipcrm",
    "ipcs",
    "iplink",
    "iproute",
    "iprule",
    "iptunnel",
    "kbd_mode",
    "kill",
    "killall",
    "killall5",
    "klogd",
    "last",
    "length",
    "less",
    "linux32",
    "linux64",
    "linuxrc",
    "ln",
    "loadfont",
    "loadkmap",
    "logger",
    "login",
    "logname",
    "logread",
    "losetup",
    "lpd",
    "lpq",
    "lpr",
    "ls",
    "lsattr",
    "lsmod",
    "lzmacat",
    "lzop",
    "lzopcat",
    "makemime",
    "man",
    "md5sum",
    "mdev",
    "mesg",
    "microcom",
    "mkdir",
    "mkdosfs",
    "mkfifo",
    "mkfs.minix",
    "mkfs.vfat",
    "mknod",
    "mkpasswd",
    "mkswap",
    "mktemp",
    "modprobe",
    "more",
    "mount",
    "mountpoint",
    "mt",
    "mv",
    "nameif",
    "nc",
    "netstat",
    "nice",
    "nmeter",
    "nohup",
    "nslookup",
    "od",
    "openvt",
    "passwd",
    "patch",
    "pgrep",
    "pidof",
    "ping",
    "ping6",
    "pipe_progress",
    "pivot_root",
    "pkill",
    "popmaildir",
    "printenv",
    "printf",
    "ps",
    "pscan",
    "pwd",
    "raidautorun",
    "rdate",
    "rdev",
    "readlink",
    "readprofile",
    "realpath",
    "reformime",
    "renice",
    "reset",
    "resize",
    "rm",
    "rmdir",
    "rmmod",
    "route",
    "rpm",
    "rpm2cpio",
    "rtcwake",
    "run-parts",
    "runlevel",
    "runsv",
    "runsvdir",
    "rx",
    "script",
    "scriptreplay",
    "sed",
    "sendmail",
    "seq",
    "setarch",
    "setconsole",
    "setfont",
    "setkeycodes",
    "setlogcons",
    "setsid",
    "setuidgid",
    "sh",
    "sha1sum",
    "sha256sum",
    "sha512sum",
    "showkey",
    "slattach",
    "sleep",
    "softlimit",
    "sort",
    "split",
    "start-stop-daemon",
    "stat",
    "strings",
    "stty",
    "su",
    "sulogin",
    "sum",
    "sv",
    "svlogd",
    "swapoff",
    "swapon",
    "switch_root",
    "sync",
    "sysctl",
    "syslogd",
    "tac",
    "tail",
    "tar",
    "taskset",
    "tcpsvd",
    "tee",
    "telnet",
    "telnetd",
    "test",
    "tftp",
    "tftpd",
    "time",
    "timeout",
    "top",
    "touch",
    "tr",
    "traceroute",
    "true",
    "tty",
    "ttysize",
    "udhcpc",
    "udhcpd",
    "udpsvd",
    "umount",
    "uname",
    "uncompress",
    "unexpand",
    "uniq",
    "unix2dos",
    "unlzma",
    "unlzop",
    "unzip",
    "uptime",
    "usleep",
    "uudecode",
    "uuencode",
    "vconfig",
    "vi",
    "vlock",
    "volname",
    "watch",
    "watchdog",
    "wc",
    "wget",
    "which",
    "who",
    "whoami",
    "xargs",
    "yes",
    "zcat",
    "zcip"
  };
  return *applets;
}

int is_special(char ascii) {
  // 33~47, 58~64, 91~96, 123~126
  if (ascii > 32 && ascii < 48) return 1;
  if (ascii > 57 && ascii < 65) return 2;
  if (ascii > 90 && ascii < 97) return 3;
  if (ascii > 122 && ascii < 127) return 4;
  return 0;
// Just a bunch of special characters
// Old bloated codes
// const char *special_characters[] = {
//   "!", // 33
//   "\"", // 34
//   "#", // 35
//   "$", // 36
//   "%", // 37
//   "&", // 38
//   "\'", // 39
//   "(", // 40
//   ")", // 41
//   "*", // 42
//   "+", // 43
//   ",", // 44
//   "-", // 45
//   ".", // 46
//   "/", // 47
//   ":", // 58
//   ";", // 59
//   "<", // 60
//   "=", // 61
//   ">", // 62
//   "\?", // 63
//   "@", // 64
//   "[", // 91
//   "\\", // 92
//   "]", // 93
//   "^", // 94
//   "_", // 95 usually treated as normal string
//   "`", // 96
//   "{", // 123
//   "|", // 124
//   "}" // 125
//   "~" // 126 $HOME
// };
// size_t list_size, prb;
// list_size = sizeof(special_characters) / sizeof(*special_characters);

// assign probe
// const char *probe;
// probe = special_characters[0];

// convert to pointer
// const char *cmp;
// cmp = &ascii;

// for (prb = 0; prb < list_size; prb++) {
//   if (strcmp(cmp, probe) == 0) return 1;
//   *probe++;
// }
// return 0;
}

void use_coloring() {
  // bourne_builtins
  const char *bourne_function[] = { // List of known bourne shell built-in functions...
    "alias",
    "break",
    "cd",
    "continue",
    "eval",
    "exec",
    "exit",
    "export",
    "getopts",
    "hash",
    "pwd",
    "readonly",
    "return",
    "shift",
    "source",
    "test",
    "times",
    "trap",
    "umask",
    "unset"
  };
  const char *bourne_constructs[] = { // List of known bourne shell constructs...
    "case",
    "do",
    "done",
    "elif",
    "esac",
    "fi",
    "for",
    "if",
    "in",
    "select",
    "then",
    "until",
    "while"
  };
  const char *bourne_variables[] = { // List of known bourne shell built-in variables...
    "~",
    "HOME",
    "IFS",
    "OPTARG",
    "OPTIND",
    "PATH",
    "PS1",
    "PS2",
    "PWD",
    "SHLVL"
  };
  // associate style & buffer
  edit->highlight_data(
    stylebuf,
    styletable,
    sizeof(styletable) / sizeof(styletable[0]),
    'A',
    style_unfinished_cb,
    0
  );
  // buff->add_modify_callback(style_update, edit);
  buff->add_modify_callback(modification_cb, edit);
}

void disable_color() {
  buff->remove_modify_callback(modification_cb, edit);
  // hopefully disable the style thing
  stylebuf->text("");
  // edit->highlight_data(NULL, NULL, NULL, NULL, NULL);
}

void modification_cb(int pos, int nInserted, int nDeleted, int nRestyled, const char *deletedText, void *cbArg) {
  int current_pos;
  current_pos = edit->insert_position();
  if (nInserted == 0 && nDeleted == 0) {
    stylebuf->unselect();
    return;
  }
  /*
  fl_alert("pos:%d\nnInserted:%d\nnDeleted:%d\nnRestyled:%d\ndeletedText:\n%s",
  pos, nInserted, nDeleted, nRestyled, deletedText);
  */
  // Insertion / deletion
  if (nInserted > 0) {
    char *cacheIN;
    cacheIN = new char[nInserted+1];
    memset(cacheIN, 'A', nInserted);
    cacheIN[nInserted] = '\0';
    stylebuf->replace(current_pos, current_pos + nDeleted, cacheIN);
    delete[] cacheIN;
  } else {
    stylebuf->remove(pos, pos + nDeleted);
  }
  // newline auto indent
  if (nInserted == 1 && buff->char_at(pos) == 10 && nDeleted == 0) {
    int lsp = buff->line_start(pos); // line start pos
    int lep = buff->line_end(pos); // line end pos
    char *indention;
    indention = new char[lep - lsp + 1];
    char *line = buff->line_text(pos);
    int i;
    for (i=0;i<(lep - lsp);i++) {
      // tab || space
      if (line[i] == 9 || line[i] == 32) indention[i] = line[i];
      else break;
    }
    indention[i] = '\0';
    // fl_alert("line:%s\nauto_indent:'%s', pos = %d", line, indention, pos);
    buff->insert(pos+1, indention);
    /* the "Insertion / deletion" section already handle the act
    // stylebuf is one char slower than buff
    stylebuf->insert(pos, "\n");
    stylebuf->insert(pos+1, indention);
    */
    current_pos += strlen(indention);
    delete[] indention;
    free(line);
  }
  edit->insert_position(current_pos);
  edit->show_insert_position();
// catch exception
  if (buff->length() != stylebuf->length()) {
    fl_alert(
      "Exception occure\nbuff->length = %d\nstylebuf->length = %d",
      buff->length(),
      stylebuf->length()
    );
  }
}

void ts_cb() {
  fl_alert("%d", buff->length());
  fl_alert("%s", buff->text());
}

void ss_cb() {
  fl_alert("%d", stylebuf->length());
  fl_alert("%s", stylebuf->text());
}

void buff_init() {
  // shebang style
  char *style_init;
  style_init = new char[buff->length() + 1];
  style_init[buff->length()] = '\0';
  int j = strlen(SHELL);
  memset(style_init, 'J', j);
  style_init[j-1] = 10; // newline
// sh syntax notes:
// X=something
// echo $X ----> something
// echo $X# ---> something#
// echo "\" ---> unterminated quoted string
// echo "\'" --> \' single quote in double quote does not escape
// echo '\' ---> \ treated literal
// echo '\'' --> unterminated quoted string
// echo "'"' --> looking for matching '
// echo '"'"' -> looking for matching "
// echo "'"'"' > '"
// echo '"'"'" > "'
// possible combination:
// both T should never happens
// sq = F, dq = F;
// sq = T, dq = F;
// sq = F, dq = T;
// style 'S': invisible chars

  // get a copy of current buffer
  char *buff_copy;
  buff_copy = buff->text();
  
  bool cm = false; // #comment 35
  bool es = false; // \escapes 92
  bool ds = false; // $dolor_sign 36
  bool se = false; // ${shell expansion}, ds must be true
  bool bq = false; // `back quote command substitution` 96
  bool sq = false; // 'single quote' 39
  bool dq = false; // "double quote" 34
  int cs = 0; // $(command substitution)
  int p = 0; // (parentheses) 40 41
  // int sb = 0; // [square brackets] 91 93
  // int cb = 0; // {curly brackets} 123 125
  
  for (;j < buff->length(); j++) {
    switch(buff_copy[j]) {
      case 10: // newline
        if (cm) cm = !cm;
      case 9: // tab
      case 32: // space
        if (ds) ds = !ds;
        style_init[j] = buff_copy[j];
        continue;
      case 35: // #comment
        if (!ds && !sq && !dq && !se) {
          cm = true;
          style_init[j] = 'J';
        }
        break;
      case 92: // \escapes
        if (cm || sq) break;
        es = true;
        break; // other escape
      case 39: // 'single quote'
        if (cm) break;
        // single quote is always
        // treated literally in double quote
        if (!dq) {
          sq = !sq;
          style_init[j] = 'F';
          continue;
        }
        break;
      case 34: // "double quote"
        if (cm) break;
        if (!sq) {
          dq = !dq;
          style_init[j] = 'G';
          if (ds) ds = !ds;
          continue;
        }
        break;
      case 96: // `back quote`
        if (cm || sq) break;
        style_init[j] = 'E';
        ds = false;
        bq = !bq;
        break;
      case 36: // $dolor_sign
        if (cm || sq) break;
        ds = true;
        switch(buff_copy[j+1]) {
          case 33: // built-in variable $!
          case 35: // built-in variable $#
          case 36: // built-in variable $$
          case 42: // built-in variable $*
          case 45: // built-in variable $-
          case 63: // built-in variable $?
          case 64: // built-in variable $@
          case 95: // built-in variable $_
            style_init[j] = 'I';
            j++;
            style_init[j] = 'I';
            ds = false;
            continue;
          case 40: // $(...
            cs++;
            p++;
            style_init[j] = 'E';
            j++;
            style_init[j] = 'E';
            ds = false;
            continue;
          case 123: // shell expansion ${
            // cb++;
            se = true; // a bit redundant
            style_init[j] = 'I';
            j++;
            style_init[j] = 'I';
            ds = true;
            continue;
          case 9: // tab
          case 10: // newline
          case 32: // space
            // trailing dolor_sign$
            ds = false;
            // use default
            style_init[j] = 'A';
            continue;
        }
        style_init[j] = 'I';
        if (is_special(style_init[j+1])) {
          // invalid variable $, or such
          ds = false;
          style_init[j] = 'A';
        }
        break;
      case 40: // (
        if (cm || sq || dq) break;
        p++;
        style_init[j] = 'C';
        break;
      case 41: // )
        if (cm || sq) break;
        if (ds) ds = !ds;
        if (dq) {
          if (cs == 0)
          break;
        }
        p--;
        style_init[j] = 'C';
        break;
      case 123: // {
        style_init[j] = 'C';
        break;
      case 125: // }
        if (cm || sq) break;
        if (ds || se) {
          // end of variable
          ds = false;
          se = false;
          style_init[j] = 'I';
          continue;
        }
        style_init[j] = 'C';
        break;
      default:
        if (cm || es || sq) break;
        style_init[j] = 'A';
    }
    if (se) {
      style_init[j] = 'I';
      continue;
    }
    if (cm) {
      switch (buff_copy[j]) {
        case 10: // newline
          cm = false;
        case 9: // tab
        case 32: // space
          style_init[j] = buff_copy[j];
          break;
        default:
          style_init[j] = 'J';
      }
      continue;
    }
    if (sq) {
      // 'single quote' ignore escapes
      style_init[j] = 'F';
      if (buff_copy[j] == 39) sq = !sq;
      continue;
    }
    if (dq) style_init[j] = 'G';
    if (ds) {
      style_init[j] = 'I';
      if (is_special(style_init[j+1]) > 0) {
        // if (is_special()) --> glitchy
        // end of variable
        ds = false;
        continue;
      }
    }
    if (es) {
      // this char = backslash (92)
      if (buff_copy[j+1]) {
        // char not null
        style_init[j] = 'H';
        style_init[j+1] = 'H';
      }
      if (dq && buff_copy[j+1] == 39) {
        /* echo "\'" --> \' */
      }
      if (buff_copy[j+1] == 120) {
        // hex \xFF 48~57, 65~70, 97~102
        bool hex = ((
          (buff_copy[j+2] > 47 && buff_copy[j+2] < 58) ||
          (buff_copy[j+2] > 64 && buff_copy[j+2] < 71) ||
          (buff_copy[j+2] > 96 && buff_copy[j+2] < 103)
        ) && (
          (buff_copy[j+3] > 47 && buff_copy[j+3] < 58) ||
          (buff_copy[j+3] > 64 && buff_copy[j+3] < 71) ||
          (buff_copy[j+3] > 96 && buff_copy[j+3] < 103)
        ));
        if (hex) {
          style_init[j+2] = 'H';
          style_init[j+3] = 'H';
          j+=2;
        }
      }
      j++;
      es = false;
      continue;
    }
    if (cs>0) {
      style_init[j] = 'E';
      if (ds) style_init[j] = 'I';
      if (buff_copy[j] == 41) {
        // )
        style_init[j] = 'E';
        cs--;
        if (p > cs) cs++;
      }
      // continue;
    }
    if (bq) {
      style_init[j] = 'E';
      // continue;
    }
  }
  
  // newly allocated text buffer - must be free'd
  free(buff_copy);
  // write to buffer and free
  style_init[buff->length()] = '\0';
  stylebuf->text(style_init);
  delete[] style_init;
}

void color_cb() {
  // color = ! color; switching handled by the button
  if (color) {
    buff_init();
    use_coloring();
    color_switch->label("NoColor");
  } else {
    disable_color();
    color_switch->label("Colorful");
    edit->redisplay_range(0, buff->length());
  }
}

Fl_Double_Window *win=(Fl_Double_Window *)0;

Fl_Text_Editor *edit=(Fl_Text_Editor *)0;

Fl_Menu_Bar *menu_bar=(Fl_Menu_Bar *)0;

static void cb_new_bt(Fl_Menu_*, void*) {
  new_cb();
}

static void cb_open(Fl_Menu_*, void*) {
  open_cb();
}

static void cb_save(Fl_Menu_*, void*) {
  save_cb();
}

static void cb_saveas(Fl_Menu_*, void*) {
  saveas_cb();
}

static void cb_sh(Fl_Menu_*, void*) {
  SHELL = "#!/bin/sh\n";
  shebang();
}

static void cb_bash(Fl_Menu_*, void*) {
  SHELL = "#!/usr/bin/env bash\n";
  shebang();
}

static void cb_color_switch(Fl_Menu_*, void*) {
  color = ! color;
  color_cb();
}

static void cb_ts_btn(Fl_Menu_*, void*) {
  ts_cb();
}

static void cb_ss_btn(Fl_Menu_*, void*) {
  ss_cb();
}

Fl_Menu_Item menu_menu_bar[] = {
 {"&File", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&New File", 0x4006e,  (Fl_Callback*)cb_new_bt, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Open", 0x4006f,  (Fl_Callback*)cb_open, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Save", 0x40073,  (Fl_Callback*)cb_save, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Save &As", 0x50073,  (Fl_Callback*)cb_saveas, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&Shell", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"POSIX sh", 0x80073,  (Fl_Callback*)cb_sh, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"ENV bash", 0x80062,  (Fl_Callback*)cb_bash, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Colorful", 0,  (Fl_Callback*)cb_color_switch, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Text size", 0,  (Fl_Callback*)cb_ts_btn, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Style size", 0,  (Fl_Callback*)cb_ss_btn, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

int main(int argc, char **argv) {
  { win = new Fl_Double_Window(425, 320);
    win->box(FL_PLASTIC_UP_BOX);
    { edit = new Fl_Text_Editor(1, 29, 424, 288);
      edit->box(FL_PLASTIC_DOWN_FRAME);
      edit->textfont(4);
      edit->textsize(20);
      Fl_Group::current()->resizable(edit);
    } // Fl_Text_Editor* edit
    { menu_bar = new Fl_Menu_Bar(0, 0, 425, 30);
      menu_bar->box(FL_PLASTIC_UP_BOX);
      menu_bar->down_box(FL_PLASTIC_DOWN_BOX);
      menu_bar->menu(menu_menu_bar);
    } // Fl_Menu_Bar* menu_bar
    win->end();
  } // Fl_Double_Window* win
  // editor init
  win->label(title);
  buffer_init();
  // if (argc > 1) load_file(argv[1]);
  win->show(argc, argv);
  return Fl::run();
}
